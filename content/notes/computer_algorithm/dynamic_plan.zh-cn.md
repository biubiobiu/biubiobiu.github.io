---
title: 五大常用算法
weight: 220
menu:
  notes:
    name: 五大常用算法
    identifier: notes-algorithm-dynamic
    parent: notes-algorithm
    weight: 30
---

{{< note title="分治法" >}}  
分治法(divide and conquer)：
1. 待解决复杂问题，能够简化为若干个小规模相同的问题，`各个子问题独立存在`，并且与原问题形式相同；
2. 递归地解决各个子问题；
3. 将各个子问题的解合并，得到原问题的解。

**示例：**<br>
归并排序
<p align="center"><img src="/datasets/note/merge_sort.png" width="100%" height="100%" title="merge_sort" alt="merge_sort"></p>
{{< /note >}}

{{< note title="动态规划" >}}  
**与分治法的不同**：<br>
动态规划与分治法相似，都是组合子问题的解来解决原问题，与分治法的不同在于：
1. 分治法：将原问题划分为一个个`不相交`的子问题（比如：归并排序，将数组不断地划分为一个个的子数组进行排序，再将返回的两个有序数组进行合并排序）
2. 动态规划：要解决的是`子问题有重叠`的问题，例如0-1背包问题。即：不同的子问题有公共的子子问题，这些重叠的子问题在动态规划中是不应该也不需要重新计算的，而是应该将其解以一定方式保存起来，提供给父问题使用。

**设计步骤**：<br>
动态规划通常用来求解`最优解问题`，这类问题会有很多个解，每个解都对应一个值，而我们则希望在这些解中找到最优解（最大值或者最小值）。
通常四个步骤设计一个动态规划算法：
1. 刻画一个最优解的结构特征，就是那个`递推公式`
2. 递归的定义最优解的值
3. 计算最优解的值，通常采用自底向上的方法；有重叠的话，就先记录下来
4. 利用计算出的信息构造一个最优解

**实现方法**：
1. 自顶向下：此方法需要一个`备忘录`来辅助实现，`备忘录`主要用来保存每一个子问题的解，当每个子问题只求一次，如果后续需要子问题的解，只需要查找备忘录中保存的结果，不必重复计算。
2. 自底向上：此方法最常用，必须明确每个子问题规模的概念，使得任何子问题的求解都依赖于子子问题的解来进行求解。

**示例：**<br>
<a href="https://www.bilibili.com/read/cv12924751" target="blank">0-1背包问题</a>

{{< /note >}}

{{< note title="贪心算法" >}}
**贪心算法**：在对问题求解时，总是做出在当前看来是做好的选择。即：`当考虑做何种选择的时候，我们只考虑对当前问题最佳的选择而不考虑子问题的结果，这是贪心算法可行的第一个基本要素`。不从整体最优上考虑，而是仅仅在某种意义上的局部最优解。贪心算法以迭代的方式作出相继的贪心选择，每做一次贪心选择就将问题简化为规模更小的子问题。

**何时采用贪心算法**：对于一个具体问题，要确定它是否具有贪心选择性质，必须证明`每一步所作的贪心选择最终导致问题的整体最优解。`

**示例：**<br>
完全背包问题、均分纸牌、最大整数

实际上，贪心算法适用的情况很少。需要先证明：`局部最优解会得出整体最优解`，才可以使用。一旦证明能成立，它就是一种高效的算法。<br>
例如【0-1背包问题】：即：对于每个物品，要么装要么不装(0或1)<br>
有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。<br>
物品： A B C D E F G<br>
重量： 35 30 60 50 40 10 25<br>
价值： 10 40 30 50 35 40 30<br>
目标函数： ∑pi最大<br>

利用贪心算法，可以这样：
1. 每次挑选价值最大的物品装入背包，（是否是最优解？）
2. 每次选择重量最小的物品装入背包，（是否是最优解？）
3. 每次选择单位重量价值最大的物品，（是否是最优解？）

上面的3中贪心策略，都无法成立，所以不能采用贪心算法。所以，`贪心算法虽然简单高效，但是能证明可以使用该算法的场景比较少。`

{{< /note >}}

{{< note title="回溯法" >}}
**回溯法：**
是一种类似枚举的搜索尝试过程，在搜索尝试过程中寻找问题的解，当发现已不满足条件时，就`回溯`返回，尝试别的路径。<br>
回溯法是一种选优搜索法，通常是创建一棵树，从根节点出发，按照深度优先搜索的策略进行搜索，到达某一节点后，搜索该节点是否包含该问题的解：a. 如果包含，则进入下一个节点进行搜索；b. 如果不包含，则`回溯`到父节点选择其他支路进行搜索。<br>

**何时采用回溯算法：** 必须有标志性操作——`搜索时不满足条件就剪枝 + 所有解`

**设计步骤**:<br>
1. 针对所给的原问题，定义问题的解空间；
2. 确定易于搜索的解空间结构；
3. 以深度优先搜索解空间，并在搜索过程中用剪枝函数除去无效搜索。

**示例：**<br>
全排列、旅行商问题、八皇后问题

{{< /note >}}


{{< note title="分支限界法" >}}
**分支限界法(branch and bound method)：** 和回溯法类似，也是一种搜索算法，与回溯法不同的是：
1. 回溯法：找出问题的许多解；通常用`深度优先`的方式搜索解空间树；
2. 分支限界法：找出原问题的一个解，或者 在满足约束条件的解中找出使某一目标函数的极大解/极小解。通常以`广度优先或最小耗费优先`的方式搜索解空间树。

在当前节点(`扩展节点`)处，生成其所有的子节点(分支)，然后再从当前节点的子节点表中选择下一个`扩展节点`。为了有效地选择下一个`扩展节点`，加速搜索的进程，在每个节点处，计算一个`限界`，从其子节点表中选择一个最有利的节点作为`扩展节点`，使搜索朝着解空间上最优解的分支推进。

**何时采用分支界限法：** 必须有标志性操作——`搜索时不满足限界就剪枝 + 最优解`

**示例：**<br>
0-1背包问题：`限界`就是背包的大小，一个节点的子节点表中，如果有超过`限界`的就直接剪枝。如下图所示：
<p align="center"><img src="/datasets/note/branch_bound.jpg" width="100%" height="100%" title="branch_bound" alt="branch_bound"></p>

{{< /note >}}
