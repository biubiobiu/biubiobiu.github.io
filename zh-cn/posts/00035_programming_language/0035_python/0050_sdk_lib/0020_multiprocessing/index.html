<!doctype html><html><head><title>并行操作</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/layouts/main.css><link rel=stylesheet href=/css/navigators/navbar.css><link rel=stylesheet href=/css/plyr.css><link rel=stylesheet href=/css/flag-icon.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600"><link rel=stylesheet href=/fontawesome/css/all.min.css><link rel=stylesheet href=/css/colortheme/colortheme.css><link rel=icon type=image/png href=/images/site/favicon_hu0d88336a9cbd3e68c7714efae786b0a9_38044_42x0_resize_box_2.png><meta property="og:title" content="并行操作"><meta property="og:description" content="一、线程与进程     进程 线程      进程：是一个应用程序在处理机上的一次执行过程，是具有一定独立功能的程序在某数据集上的一次运行，是一个动态的概念。进程是系统进行资源分配和调度的独立单位。 线程：是进程中的一个实体，是CPU调度和分派的基本单位，线程自己基本上不拥有系统资源，它与同属于一个进程内的其他线程共享进程的全部资源。   地址空间 进程有自己独立的地址空间 进程中至少有一个线程，它们共享进程的地址空间   资源 进程是资源分配和拥有的单位 进程内的多个线程共享进程的资源   调度  线程是进程内的一个执行单元，也是进程内的可调度实体，也是处理器调度的基本单位    二、多线程 1、threading模块 python主要是通过thread和threading这两个模块来实现多线程，thread模块是比较底层的模块，threading模块是对thread做了一些封装，使用更方便。但是由于GIL的存在，无法使用threading充分利用CPU资源，如果想充分发挥多核CPU的计算能力，需要使用multiprocessing模块
python 3.x 已经摒弃了python 2.x中采用函数式thread模块来产生线程的方式。而是通过threading模块创建新的线程：
  通过threading.Thread(Target=可执行方法)
import threading pro_list = [] mult_image_label_list = [] for index, img_list in enumerate(mult_image_label_list): # 创建线程 t1 = threading.Thread(target=函数名, args=(index, img_list)) pro_list.append(t1) for thread in pro_list: # 将线程设置为保护线程，否则会被无限挂起。 thread.setDaemon(True) thread."><meta property="og:type" content="article"><meta property="og:url" content="https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0020_multiprocessing/"><meta property="article:published_time" content="2021-09-08T06:00:20+08:00"><meta property="article:modified_time" content="2021-09-08T06:00:20+08:00"><meta name=description content="并行操作"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/atom-one-dark.min.css><link rel=stylesheet href=/css/layouts/single.css><link rel=stylesheet href=/css/navigators/sidebar.css><link rel=stylesheet href=/css/style.css></head><body data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-dimmed wrapper"><nav class="navbar navbar-expand-xl top-navbar final-navbar shadow"><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button onclick=toggleSidebar()>
<span class=navbar-toggler-icon></span></button>
<a class=navbar-brand href=/zh-cn><img src=/images/site/main-logo_hu245540b1d52c0d501ae7bc0752a15caf_34633_42x0_resize_box_2.png alt=Logo>
biubiobiu's Blog</a>
<button class="navbar-toggler navbar-light" id=toc-toggler type=button onclick=toggleTOC()>
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse lang-selector" id=top-nav-items><ul class="navbar-nav ml-auto"><li class="nav-item dropdown"><div id=theme-initialization style=display:none default-theme=system></div><a class="nav-link dropdown-toggle" href=# id=themeSelector role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false><img id=navbar-theme-icon-svg src=/icons/moon-svgrepo-com.svg width=20></a><div class="dropdown-menu dropdown-menu-icons-only" aria-labelledby=themeSelector><a class="dropdown-item nav-link" href=# onclick=enableLightTheme()><img class=menu-icon-center src=/icons/sun-svgrepo-com.svg width=20></a>
<a class="dropdown-item nav-link" href=# onclick=enableDarkTheme()><img class=menu-icon-center src=/icons/moon-svgrepo-com.svg width=20></a>
<a class="dropdown-item nav-link" href=# onclick=useSystemTheme()><img class=menu-icon-center src=/icons/computer-svgrepo-com.svg width=20></a></div></li></ul></div></div><img src=/images/site/main-logo_hu245540b1d52c0d501ae7bc0752a15caf_34633_42x0_resize_box_2.png class=d-none id=main-logo alt=Logo>
<img src=/images/site/inverted-logo_hu547c3206082786c1d32d36034e2a655a_40863_42x0_resize_box_2.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/zh-cn/search><input type=text name=keyword placeholder=搜索 data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/zh-cn/posts data-filter=all>博文</a></li><div class=subtree><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00020_toha-tutorial/>Toha教程</a><ul><li><a href=/zh-cn/posts/00020_toha-tutorial/0010_toha-config/ title=Toha的配置>Toha的配置</a></li><li><a href=/zh-cn/posts/00020_toha-tutorial/0011_write-blogs/ title=撰写文章>撰写文章</a></li><li><a href=/zh-cn/posts/00020_toha-tutorial/0013_markdown-tutorial/ title=MarkDown入门>MarkDown入门</a></li><li><a href=/zh-cn/posts/00020_toha-tutorial/0015_latax_formula/ title=Katex公式>Katex公式</a></li><li><a href=/zh-cn/posts/00020_toha-tutorial/0020_shortcodes_samples/ title=区域块-实例>区域块-实例</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00025_math_knowledge/>数学知识</a><ul><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00025_math_knowledge/0010_math_probability_theory/>概率论</a><ul><li><a href=/zh-cn/posts/00025_math_knowledge/0010_math_probability_theory/0010_basic-conception/ title=基本概念>基本概念</a></li><li><a href=/zh-cn/posts/00025_math_knowledge/0010_math_probability_theory/0020_distribution_of_variables/ title=随机变量及其分布>随机变量及其分布</a></li><li><a href=/zh-cn/posts/00025_math_knowledge/0010_math_probability_theory/0030_law_of_large_numbers/ title=大数定律>大数定律</a></li><li><a href=/zh-cn/posts/00025_math_knowledge/0010_math_probability_theory/0040_sample_distribution/ title=样本及抽样分布>样本及抽样分布</a></li><li><a href=/zh-cn/posts/00025_math_knowledge/0010_math_probability_theory/0050_parameter_estimation/ title=假设检验>假设检验</a></li><li><a href=/zh-cn/posts/00025_math_knowledge/0010_math_probability_theory/0060_analysis_variance_regression/ title=方差分析及回归分析>方差分析及回归分析</a></li><li><a href=/zh-cn/posts/00025_math_knowledge/0010_math_probability_theory/0070_stochastic_process/ title=随机过程>随机过程</a></li><li><a href=/zh-cn/posts/00025_math_knowledge/0010_math_probability_theory/0080_markov_process/ title=马尔科夫链>马尔科夫链</a></li><li><a href=/zh-cn/posts/00025_math_knowledge/0010_math_probability_theory/0090_stationary_stochastic_process/ title=平稳随机过程>平稳随机过程</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00025_math_knowledge/0020_math_convex_optimization_theory/>凸优化</a><ul><li><a href=/zh-cn/posts/00025_math_knowledge/0020_math_convex_optimization_theory/0010_basic_conception/ title=基本概念>基本概念</a></li></ul></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00030_deeplearning_summary/>深度学习</a><ul><li><a href=/zh-cn/posts/00030_deeplearning_summary/0005_deeplearning_summary/ title=深度学习开篇>深度学习开篇</a></li><li><a href=/zh-cn/posts/00030_deeplearning_summary/0010_deeplearning_problem/ title=深度学习-结构>深度学习-结构</a></li><li><a href=/zh-cn/posts/00030_deeplearning_summary/0100_draw_map_for_dl/ title=神经网络画图篇>神经网络画图篇</a></li><li><a href=/zh-cn/posts/00030_deeplearning_summary/0200_cam/ title=CAM>CAM</a></li></ul></li><li><i class="fas fa-minus-circle"></i><a class=active href=/zh-cn/posts/00035_programming_language/>编程语言</a><ul class=active><li><i class="fas fa-minus-circle"></i><a class=active href=/zh-cn/posts/00035_programming_language/0035_python/>Python</a><ul class=active><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00035_programming_language/0035_python/0010_build_env/>env</a><ul><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0010_build_env/0010_pip_env/ title=py-env>py-env</a></li><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0010_build_env/0020_cuda_env/ title=cuda>cuda</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/>Internal</a><ul><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0010_encode_mode/ title=字符编码>字符编码</a></li><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0020_basic_operator/ title=基础操作>基础操作</a></li><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0025_internal_module/ title=内置模块>内置模块</a></li><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0030_advance_operator/ title=进阶操作>进阶操作</a></li><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0040_error/ title=异常>异常</a></li><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0050_file/ title=文件读取>文件读取</a></li></ul></li><li><i class="fas fa-minus-circle"></i><a class=active href=/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/>SDK</a><ul class=active><li><a class=active href=/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0020_multiprocessing/ title=并行操作>并行操作</a></li><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0030_importlib/ title=importlib>importlib</a></li><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0040_ipdb/ title=ipdb>ipdb</a></li><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0050_re/ title=正则-re>正则-re</a></li><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0060_heapd/ title=堆-heapd>堆-heapd</a></li><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0070_request/ title=requests>requests</a></li><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0080_logging/ title=logging>logging</a></li><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0090_argparse/ title=argparse>argparse</a></li><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0100_pil/ title=PIL>PIL</a></li><li><a href=/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0110_opencv/ title=OpenCV>OpenCV</a></li></ul></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00035_programming_language/0040_tf/>TensorFlow</a><ul><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00035_programming_language/0040_tf/w0010_compat/>兼容1.x</a><ul><li><a href=/zh-cn/posts/00035_programming_language/0040_tf/w0010_compat/0010_tf_compat_summary/ title=静态图>静态图</a></li><li><a href=/zh-cn/posts/00035_programming_language/0040_tf/w0010_compat/0020_tf_compat_train/ title=模型训练>模型训练</a></li></ul></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00035_programming_language/0050_pytorch/>PyTorch</a><ul><li><a href=/zh-cn/posts/00035_programming_language/0050_pytorch/0010_torch_summary/ title=简介>简介</a></li><li><a href=/zh-cn/posts/00035_programming_language/0050_pytorch/0020_basic/ title=基础操作>基础操作</a></li><li><a href=/zh-cn/posts/00035_programming_language/0050_pytorch/0030_mathematical/ title=数学计算>数学计算</a></li><li><a href=/zh-cn/posts/00035_programming_language/0050_pytorch/0040_tensor/ title=Tensor和变量>Tensor和变量</a></li><li><a href=/zh-cn/posts/00035_programming_language/0050_pytorch/0050_train_model/ title=模型训练>模型训练</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00035_programming_language/0060_mxnet/>MxNet</a><ul><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00035_programming_language/0060_mxnet/0010_ndarray/>NdArray</a><ul><li><a href=/zh-cn/posts/00035_programming_language/0060_mxnet/0010_ndarray/0010_ndarray_summary/ title=NdArray使用>NdArray使用</a></li></ul></li></ul></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00100_cv/>CV</a><ul><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00100_cv/0010_backbone/>基础</a><ul><li><a href=/zh-cn/posts/00100_cv/0010_backbone/d1_1_backbone_cnn/ title=CNN>CNN</a></li><li><a href=/zh-cn/posts/00100_cv/0010_backbone/d1_2_optimizer/ title=optimizer>optimizer</a></li><li><a href=/zh-cn/posts/00100_cv/0010_backbone/d1_3_backbone_net/ title="backbone net">backbone net</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00100_cv/0020_contrastive_learning/>对比学习</a><ul><li><a href=/zh-cn/posts/00100_cv/0020_contrastive_learning/contrastive_learning/ title="contrastive learning">contrastive learning</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00100_cv/0030_vision_transformer/>ViT</a><ul><li><a href=/zh-cn/posts/00100_cv/0030_vision_transformer/vision_transformer/ title="vision transformer">vision transformer</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00100_cv/0050_detect_object/>目标检测</a><ul><li><a href=/zh-cn/posts/00100_cv/0050_detect_object/object_detection_summary/ title=简介>简介</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00100_cv/0055_semantic_segmentation/>语义分割</a><ul><li><a href=/zh-cn/posts/00100_cv/0055_semantic_segmentation/object_detection_summary/ title=简介>简介</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00100_cv/0060_image-matting/>抠图</a><ul><li><a href=/zh-cn/posts/00100_cv/0060_image-matting/image-matting-summary/ title=抠图综述>抠图综述</a></li><li><a href=/zh-cn/posts/00100_cv/0060_image-matting/image-matting-animal/ title="animal matting">animal matting</a></li></ul></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00200_nlp/>NLP</a><ul><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00200_nlp/0010_word_embedding/>Word Embedding</a><ul><li><a href=/zh-cn/posts/00200_nlp/0010_word_embedding/word_embedding_summary/ title="Word Embedding综述">Word Embedding综述</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00200_nlp/0020_rnn/>RNN</a><ul><li><a href=/zh-cn/posts/00200_nlp/0020_rnn/rnn_summary/ title=RNN综述>RNN综述</a></li><li><a href=/zh-cn/posts/00200_nlp/0020_rnn/gru/ title=GRU网络>GRU网络</a></li><li><a href=/zh-cn/posts/00200_nlp/0020_rnn/lstm/ title=LSTM网络>LSTM网络</a></li><li><a href=/zh-cn/posts/00200_nlp/0020_rnn/encode_decode/ title=编解码架构>编解码架构</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00200_nlp/0030_transformer/>Transformer</a><ul><li><a href=/zh-cn/posts/00200_nlp/0030_transformer/attention/ title=Attention>Attention</a></li><li><a href=/zh-cn/posts/00200_nlp/0030_transformer/transformer_summary/ title=Transformer>Transformer</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00200_nlp/0080_gpt/>GPT</a><ul><li><a href=/zh-cn/posts/00200_nlp/0080_gpt/0010_gpt_summary/ title=GPT综述>GPT综述</a></li><li><a href=/zh-cn/posts/00200_nlp/0080_gpt/0020_gpt1_detail/ title=GPT-1>GPT-1</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00200_nlp/0100_bert/>Bert</a><ul><li><a href=/zh-cn/posts/00200_nlp/0100_bert/bert_summary/ title=Bert综述>Bert综述</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00200_nlp/0150_bart/>BART</a><ul><li><a href=/zh-cn/posts/00200_nlp/0150_bart/bart_summary/ title=BART综述>BART综述</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00200_nlp/0200_electra/>ELECTRA</a><ul><li><a href=/zh-cn/posts/00200_nlp/0200_electra/electra_summary/ title=ELECTRA综述>ELECTRA综述</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00200_nlp/1000_code/>CODE</a><ul><li><a href=/zh-cn/posts/00200_nlp/1000_code/bart_summary/ title=code解析>code解析</a></li></ul></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00300_aigc/>AIGC</a><ul><li><a href=/zh-cn/posts/00300_aigc/0010_aigc_summary/ title=简介>简介</a></li><li><a href=/zh-cn/posts/00300_aigc/0012_generate_summary/ title=生成模型-简介>生成模型-简介</a></li><li><a href=/zh-cn/posts/00300_aigc/0015_llama_summary/ title=LLaMa>LLaMa</a></li><li><a href=/zh-cn/posts/00300_aigc/0100_diffusion_summary_/ title=模型介绍>模型介绍</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00400_vlp/>多模态</a><ul><li><a href=/zh-cn/posts/00400_vlp/vlp_summary/ title=简介>简介</a></li><li><a href=/zh-cn/posts/00400_vlp/clip/ title=CLIP>CLIP</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh-cn/posts/00500_video/>视频理解</a><ul><li><a href=/zh-cn/posts/00500_video/vidio_summary/ title=简介>简介</a></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class=content><div class="container p-0 read-area"><div class="hero-area col-sm-12" id=hero-area style=background-image:url(/images/default-hero.jpg)></div><div class=page-content><div class="author-profile ml-auto align-self-lg-center"><img class=rounded-circle src=/images/author/john_hu7f9991f5b5d471ecdfc6cff3db1a9fe6_6397_120x120_fit_box_2.png alt="Author Image"><h5 class=author-name>biubiobiu</h5><p>September 8, 2021</p></div><div class=title><h1>并行操作</h1></div><div class=taxonomy-terms><ul><li class=rounded><a href=/zh-cn/tags/python class="btn, btn-sm">python</a></li><li class=rounded><a href=/zh-cn/tags/%E5%B9%B6%E8%A1%8C class="btn, btn-sm">并行</a></li></ul></div><div class=post-content id=post-content><h2 id=一线程与进程>一、线程与进程</h2><table><thead><tr><th style=text-align:left></th><th style=text-align:left>进程</th><th style=text-align:left>线程</th></tr></thead><tbody><tr><td style=text-align:left></td><td style=text-align:left><code>进程</code>：是一个应用程序在处理机上的一次执行过程，是具有一定独立功能的程序在某数据集上的一次运行，是一个<code>动态</code>的概念。进程是系统进行资源分配和调度的独立单位。</td><td style=text-align:left><code>线程</code>：是进程中的一个实体，是CPU调度和分派的基本单位，线程自己基本上不拥有系统资源，它与同属于一个进程内的其他线程共享进程的全部资源。</td></tr><tr><td style=text-align:left>地址空间</td><td style=text-align:left>进程有自己独立的地址空间</td><td style=text-align:left>进程中至少有一个线程，它们共享进程的地址空间</td></tr><tr><td style=text-align:left>资源</td><td style=text-align:left>进程是资源分配和拥有的单位</td><td style=text-align:left>进程内的多个线程共享进程的资源</td></tr><tr><td style=text-align:left>调度</td><td style=text-align:left></td><td style=text-align:left><code>线程</code>是进程内的一个执行单元，也是进程内的可调度实体，也是处理器调度的基本单位</td></tr></tbody></table><h2 id=二多线程>二、多线程</h2><h3 id=1threading模块>1、<code>threading模块</code></h3><p>python主要是通过<code>thread</code>和<code>threading</code>这两个模块来实现多线程，<code>thread</code>模块是比较底层的模块，<code>threading</code>模块是对thread做了一些封装，使用更方便。但是由于GIL的存在，无法使用threading充分利用CPU资源，如果想充分发挥多核CPU的计算能力，需要使用<code>multiprocessing</code>模块<br></p><p>python 3.x 已经摒弃了python 2.x中采用函数式thread模块来产生线程的方式。而是通过threading模块创建新的线程：</p><ol><li><p>通过<code>threading.Thread(Target=可执行方法)</code><br></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> threading
pro_list <span style=color:#f92672>=</span> []
mult_image_label_list <span style=color:#f92672>=</span> []
<span style=color:#66d9ef>for</span> index, img_list <span style=color:#f92672>in</span> enumerate(mult_image_label_list):
    <span style=color:#75715e># 创建线程</span>
    t1 <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span><span style=color:#960050;background-color:#1e0010>函数名</span>, args<span style=color:#f92672>=</span>(index, img_list))
    pro_list<span style=color:#f92672>.</span>append(t1)
   
<span style=color:#66d9ef>for</span> thread <span style=color:#f92672>in</span> pro_list:
    <span style=color:#75715e># 将线程设置为保护线程，否则会被无限挂起。</span>
    thread<span style=color:#f92672>.</span>setDaemon(True)
    thread<span style=color:#f92672>.</span>start()
   
<span style=color:#75715e># 该位置---子线程与父线程同时执行，父线程执行完后，同时结束子线程的执行。</span>
<span style=color:#75715e># 如果不添加join()语句，父线程结束后，子线程就会结束。</span>
<span style=color:#75715e># 如果需要在子线程执行完后，父线程才结束，需要添加join()，让父进程一直处于阻塞状态，直到所有子线程执行完毕。</span>
   
<span style=color:#66d9ef>for</span> thread <span style=color:#f92672>in</span> pro_list:
  <span style=color:#75715e># 在子线程结束前，父线程一直处于阻塞状态。让子线程执行完，才执行父线程，添加join()。</span>
  thread<span style=color:#f92672>.</span>join()
   
</code></pre></div></li><li><p>继承<code>threading.Thread</code>定义子类，并重写<code>run()</code>方法和<code>init()</code><br>实例化后调用start()方法启动新线程，即：它调用了线程的run()方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> threading
<span style=color:#f92672>import</span> time
   
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>myThread</span>(threading<span style=color:#f92672>.</span>Thread):
  <span style=color:#66d9ef>def</span> __init__(self, threadID, name, counter):
    threading<span style=color:#f92672>.</span>Thread<span style=color:#f92672>.</span>__init__(self)
    self<span style=color:#f92672>.</span>threadID <span style=color:#f92672>=</span> threadID
    self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
    self<span style=color:#f92672>.</span>counter <span style=color:#f92672>=</span> counter
   
  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Starting &#34;</span> <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>name)
    print_time(self<span style=color:#f92672>.</span>name, self<span style=color:#f92672>.</span>counter, <span style=color:#ae81ff>5</span>)
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Exiting &#34;</span> <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>name)
   
   
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_time</span>(threadName, delay, counter):
   <span style=color:#66d9ef>while</span> counter:
      time<span style=color:#f92672>.</span>sleep(delay)
      <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74> process at: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> (threadName, time<span style=color:#f92672>.</span>ctime(time<span style=color:#f92672>.</span>time())))
      counter <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>


<span style=color:#75715e># 创建新线程</span>
thread1 <span style=color:#f92672>=</span> myThread(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;Thread-1&#34;</span>, <span style=color:#ae81ff>1</span>)
thread2 <span style=color:#f92672>=</span> myThread(<span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#34;Thread-2&#34;</span>, <span style=color:#ae81ff>2</span>)
   
<span style=color:#75715e># 开启线程</span>
thread1<span style=color:#f92672>.</span>start()
thread2<span style=color:#f92672>.</span>start()
   
<span style=color:#75715e># 等待线程结束</span>
thread1<span style=color:#f92672>.</span>join()
thread2<span style=color:#f92672>.</span>join()
   
<span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Exiting Main Thread&#34;</span>)
   
</code></pre></div><p>上例中thread1和thread2执行顺序是乱序的，如果要使其有序，需要进行线程同步。<br>如果多个线程共同对某个数据操作，可能会出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。<code>threading.Lock()</code>有acquire方法(进行加锁)和release方法(进行解锁)，对于需要每次只允许一个线程操作的数据，可以将其操作放在acquire和release方法之间。<code>线程同步的方式：锁机制、同步队列</code></p><ol><li>锁机制</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>myThread</span>(threading<span style=color:#f92672>.</span>Thread):
    <span style=color:#66d9ef>def</span> __init__(self, threadID, name, counter, lock):
        threading<span style=color:#f92672>.</span>Thread<span style=color:#f92672>.</span>__init__(self)
        self<span style=color:#f92672>.</span>threadID <span style=color:#f92672>=</span> threadID
        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
        self<span style=color:#f92672>.</span>counter <span style=color:#f92672>=</span> counter
        self<span style=color:#f92672>.</span>lock <span style=color:#f92672>=</span> lock
   
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):
        <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Starting &#34;</span> <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>name)
        <span style=color:#75715e># 加锁</span>
        self<span style=color:#f92672>.</span>lock<span style=color:#f92672>.</span>acquire()
        print_time(self<span style=color:#f92672>.</span>name, self<span style=color:#f92672>.</span>counter, <span style=color:#ae81ff>5</span>)
        <span style=color:#75715e># 解锁</span>
        self<span style=color:#f92672>.</span>lock<span style=color:#f92672>.</span>release()
        <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Exiting &#34;</span> <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>name)
   
   
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_time</span>(threadName, delay, counter):
    <span style=color:#66d9ef>while</span> counter:
        time<span style=color:#f92672>.</span>sleep(delay)
        <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74> process at: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> (threadName, time<span style=color:#f92672>.</span>ctime(time<span style=color:#f92672>.</span>time())))
        counter <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
lock <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Lock()

<span style=color:#75715e># 创建新线程</span>
thread1 <span style=color:#f92672>=</span> myThread(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;Thread-1&#34;</span>, <span style=color:#ae81ff>1</span>, lock)
thread2 <span style=color:#f92672>=</span> myThread(<span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#34;Thread-2&#34;</span>, <span style=color:#ae81ff>2</span>, lock)

<span style=color:#75715e># 开启线程</span>
thread1<span style=color:#f92672>.</span>start()
thread2<span style=color:#f92672>.</span>start()

<span style=color:#75715e># 等待线程结束</span>
thread1<span style=color:#f92672>.</span>join()
thread2<span style=color:#f92672>.</span>join()

<span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Exiting Main Thread&#34;</span>)
</code></pre></div><ol start=2><li>线程同步队列queue<br>python 2.x 提供的Queue，python3.x中提供的是queue。其中queue模块找那个提供了同步的、线程安全队列类，包括：FIFO(先入先出队列)、LIFO(后入先出队列)、PriorityQueue(优先级别队列)。这些队列都实现了锁原语，能够在多线程中直接使用。<br>可以使用队列来实现线程间的同步。<table><thead><tr><th style=text-align:left>queue常用方法</th><th></th></tr></thead><tbody><tr><td style=text-align:left>queue.qsize()</td><td style=text-align:left>返回队列的大小</td></tr><tr><td style=text-align:left>queue.empty()</td><td style=text-align:left>如果队列为空，返回True，否则返回False</td></tr><tr><td style=text-align:left>queue.full()</td><td style=text-align:left>如果队列满了，返回True，否则返回False</td></tr><tr><td style=text-align:left>queue.get()</td><td style=text-align:left>获取队列</td></tr><tr><td style=text-align:left>queue.get_nowait()</td><td style=text-align:left>相当于Queue.get(False)</td></tr><tr><td style=text-align:left>queue.put()</td><td style=text-align:left>写入队列</td></tr><tr><td style=text-align:left>queue.put_nowait(item)</td><td style=text-align:left>相当于Queue.put(item, False)</td></tr><tr><td style=text-align:left>queue.task_done()</td><td style=text-align:left>在完成一项工作之后，向任务已经完成的队列发送一个信号</td></tr><tr><td style=text-align:left>queue.join()</td><td style=text-align:left>实际上意味着等到队列为空，再执行别的操作</td></tr></tbody></table></li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e>#!/usr/bin/python3</span>

<span style=color:#f92672>import</span> queue
<span style=color:#f92672>import</span> threading
<span style=color:#f92672>import</span> time

exitFlag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>myThread</span> (threading<span style=color:#f92672>.</span>Thread):
    <span style=color:#66d9ef>def</span> __init__(self, threadID, name, q):
        threading<span style=color:#f92672>.</span>Thread<span style=color:#f92672>.</span>__init__(self)
        self<span style=color:#f92672>.</span>threadID <span style=color:#f92672>=</span> threadID
        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
        self<span style=color:#f92672>.</span>q <span style=color:#f92672>=</span> q
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):
        <span style=color:#66d9ef>print</span> (<span style=color:#e6db74>&#34;开启线程：&#34;</span> <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>name)
        process_data(self<span style=color:#f92672>.</span>name, self<span style=color:#f92672>.</span>q)
        <span style=color:#66d9ef>print</span> (<span style=color:#e6db74>&#34;退出线程：&#34;</span> <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>name)

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>process_data</span>(threadName, q):
    <span style=color:#66d9ef>while</span> <span style=color:#f92672>not</span> exitFlag:
        queueLock<span style=color:#f92672>.</span>acquire()
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> workQueue<span style=color:#f92672>.</span>empty():
            data <span style=color:#f92672>=</span> q<span style=color:#f92672>.</span>get()
            queueLock<span style=color:#f92672>.</span>release()
            <span style=color:#66d9ef>print</span> (<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74> processing </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> (threadName, data))
        <span style=color:#66d9ef>else</span>:
            queueLock<span style=color:#f92672>.</span>release()
        time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>1</span>)

threadList <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;Thread-1&#34;</span>, <span style=color:#e6db74>&#34;Thread-2&#34;</span>, <span style=color:#e6db74>&#34;Thread-3&#34;</span>]
nameList <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;One&#34;</span>, <span style=color:#e6db74>&#34;Two&#34;</span>, <span style=color:#e6db74>&#34;Three&#34;</span>, <span style=color:#e6db74>&#34;Four&#34;</span>, <span style=color:#e6db74>&#34;Five&#34;</span>]
queueLock <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Lock()
workQueue <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>Queue(<span style=color:#ae81ff>10</span>)
threads <span style=color:#f92672>=</span> []
threadID <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>

<span style=color:#75715e># 创建新线程</span>
<span style=color:#66d9ef>for</span> tName <span style=color:#f92672>in</span> threadList:
    thread <span style=color:#f92672>=</span> myThread(threadID, tName, workQueue)
    thread<span style=color:#f92672>.</span>start()
    threads<span style=color:#f92672>.</span>append(thread)
    threadID <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>

<span style=color:#75715e># 填充队列</span>
queueLock<span style=color:#f92672>.</span>acquire()
<span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> nameList:
    workQueue<span style=color:#f92672>.</span>put(word)
queueLock<span style=color:#f92672>.</span>release()

<span style=color:#75715e># 等待队列清空</span>
<span style=color:#66d9ef>while</span> <span style=color:#f92672>not</span> workQueue<span style=color:#f92672>.</span>empty():
    <span style=color:#66d9ef>pass</span>

<span style=color:#75715e># 通知线程是时候退出</span>
exitFlag <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>

<span style=color:#75715e># 等待所有线程完成</span>
<span style=color:#66d9ef>for</span> t <span style=color:#f92672>in</span> threads:
    t<span style=color:#f92672>.</span>join()
<span style=color:#66d9ef>print</span> (<span style=color:#e6db74>&#34;退出主线程&#34;</span>)
</code></pre></div></li></ol><h3 id=2threadpoolexecutor线程池>2、<code>ThreadPoolExecutor线程池</code></h3><blockquote><p><code>传统多线程问题</code>：一个线程的运行时间可以分为3部分：线程的启动时间、线程体的运行时间、线程的销毁时间。<code>如果线程不能被重用，这就意味着每次创建都需要经过启动、运行、销毁这3个过程。</code>这必然会增加系统响应的时间，降低效率。另外一种高效的解决方法——线程池。<br><code>线程池</code>：把任务放进队列中，然后开N个线程，每个线程都取队列中取一个任务，执行完了之后告诉系统我执行完了，然后接着从队列中取下一个任务，直至队列中所有任务取空，退出线程。由于线程预先被穿件并放入线程池中，同时处理完当前任务之后并不销毁而是被安排处理下一个任务，因此能够避免多次穿件线程，从而节省线程创建和销毁的开销，能带来更好的性能和系统稳定性。<br><code>线程池设置</code>：服务器CPU核数有限，能够同时并发的线程数有限，并不是开得越多越好。线程切换是有开销的，如果线程切换过于频繁，反而会使性能降低。假设N核服务器，通过执行业务的单线程分析出本地计算时间x，等待时间为y，则工作线程数设置为 N*(x+y)/x，能让CPU的利用率最大化。</p></blockquote><p>从python3.2开始，标准库提供了<code>concurrent.futures</code>模块，它提供了<code>ThreadPoolExecutor</code>和<code>ProcessPoolExecutor</code>两个类，实现了对<code>threading</code>和<code>multiprocessing</code>的进一步抽象。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> concurrent.futures <span style=color:#f92672>import</span> ThreadPoolExecutor, as_completed
<span style=color:#f92672>import</span> time

<span style=color:#75715e># 参数times用来模拟网络请求的时间</span>
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_html</span>(times):
    time<span style=color:#f92672>.</span>sleep(times)
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;get page {}s finished&#34;</span><span style=color:#f92672>.</span>format(times))
    <span style=color:#66d9ef>return</span> times

executor <span style=color:#f92672>=</span> ThreadPoolExecutor(max_workers<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
urls <span style=color:#f92672>=</span> [<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>] <span style=color:#75715e># 并不是真的url</span>

<span style=color:#75715e># 方法：as_completed</span>
all_task <span style=color:#f92672>=</span> [executor<span style=color:#f92672>.</span>submit(get_html, url) <span style=color:#66d9ef>for</span> url <span style=color:#f92672>in</span> urls]
<span style=color:#66d9ef>for</span> future <span style=color:#f92672>in</span> as_completed(all_task):
    data <span style=color:#f92672>=</span> future<span style=color:#f92672>.</span>result()
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;in main: get page {}s success&#34;</span><span style=color:#f92672>.</span>format(data))
<span style=color:#75715e># 执行结果</span>
<span style=color:#75715e># get page 2s finished</span>
<span style=color:#75715e># in main: get page 2s success</span>
<span style=color:#75715e># get page 3s finished</span>
<span style=color:#75715e># in main: get page 3s success</span>
<span style=color:#75715e># get page 4s finished</span>
<span style=color:#75715e># in main: get page 4s success</span>

<span style=color:#75715e># 方法：map</span>
<span style=color:#66d9ef>for</span> data <span style=color:#f92672>in</span> executor<span style=color:#f92672>.</span>map(get_html, urls):
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;in main: get page {}s success&#34;</span><span style=color:#f92672>.</span>format(data))
<span style=color:#75715e># 执行结果</span>
<span style=color:#75715e># get page 2s finished</span>
<span style=color:#75715e># get page 3s finished</span>
<span style=color:#75715e># in main: get page 3s success</span>
<span style=color:#75715e># in main: get page 2s success</span>
<span style=color:#75715e># get page 4s finished</span>
<span style=color:#75715e># in main: get page 4s success</span>

</code></pre></div><p><code>ThreadPoolExecutor</code>构造实例的时候，传入<code>max_workers</code>参数：来设置线程池中最多能同时运行的线程数目。</p><table><thead><tr><th style=text-align:left>常用方法</th><th></th></tr></thead><tbody><tr><td style=text-align:left>submit()</td><td style=text-align:left>用来提交线程池需要执行的任务到线程池中，并返回该任务的句柄，注意：submit不是阻塞的，而是立即返回。<br><code>任务句柄</code>能够使用<code>done()</code>方法来判断该任务是否结束。</td></tr><tr><td style=text-align:left>cancel()</td><td style=text-align:left>可以取消提交的任务。如果任务已经在线程池中运行了，就取消不了了。</td></tr><tr><td style=text-align:left>result()</td><td style=text-align:left>获取任务的返回值，这个方法内部是阻塞的。</td></tr><tr><td style=text-align:left>as_completed()</td><td style=text-align:left>判断线程池中那些任务结束了。as_completed方法是一个生成器，在没有任务完成的时候，会阻塞；在有任务完成时，会yield该任务，然后继续阻塞</td></tr><tr><td style=text-align:left>map()</td><td></td></tr><tr><td style=text-align:left>wait()</td><td></td></tr></tbody></table><h2 id=三多进程>三、多进程</h2><h3 id=1multiprocessing模块>1、<code>multiprocessing模块</code></h3><p><code>multiprocessing模块</code>是python中的多进程管理包，与thread.Thread类似，可以利用<code>multiprocessing.Process</code>对象来创建一个进程。该Process对象与Thread对象的用法相同，也有start()，run()，join()方法。</p><blockquote><ol><li>在unix平台上，在某个进程结束之后，该进程需要被其父进程调用wait，否则进程成为僵尸进程(zombie)，所以，有必要对每个Process对象调用join方法(等同于wait)。</li><li><code>multiprocessing模块</code>提供了threading包没有的IPC(比如Pipe和Queue)，效率更高，应该优先考虑Pipe和Queue，避免使用Lock/Event/Semaphore/Condition等同步方式。</li><li>多进程应该避免共享资源。多线程本来就共享资源，可以方便的使用全局变量。各进程有自己的独立空间，共享资源会降低程序的效率。对于多进程，可以通过Manager方法来共享资源。</li></ol></blockquote><h4 id=多进程>多进程：</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> multiprocessing

q_input <span style=color:#f92672>=</span> multiprocessing<span style=color:#f92672>.</span>Queue(<span style=color:#ae81ff>100</span>)
q_output <span style=color:#f92672>=</span> multiprocessing<span style=color:#f92672>.</span>Queue(<span style=color:#ae81ff>100</span>)

all_task <span style=color:#f92672>=</span> []
<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>):
    all_task<span style=color:#f92672>.</span>append(multiprocessing<span style=color:#f92672>.</span>Process(target<span style=color:#f92672>=</span><span style=color:#960050;background-color:#1e0010>函数名</span>, args<span style=color:#f92672>=</span>(<span style=color:#960050;background-color:#1e0010>形参</span>)))

<span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> all_task:
    p<span style=color:#f92672>.</span>daemon <span style=color:#f92672>=</span> True
    p<span style=color:#f92672>.</span>start()

<span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> all_task:
    p<span style=color:#f92672>.</span>join()

</code></pre></div><h4 id=进程池process-pool>进程池(Process Pool)</h4><p>进程池可以创建多个进程，这些进程就像随时待命的士兵，准备执行任务，一个进程池中可以容纳多个待命的进程。如下：Pool创建了一个容许5个进程的进程池，每个进程都执行f函数，利用map方法将f()函数作用到表的每个元素上。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> multiprocessing

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>f</span>(x):
    <span style=color:#66d9ef>return</span> x<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>

pool <span style=color:#f92672>=</span> multiprocessing<span style=color:#f92672>.</span>Pool(processes<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>)

<span style=color:#75715e>#-------map-------#</span>
result <span style=color:#f92672>=</span> pool<span style=color:#f92672>.</span>map(f, [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>])
<span style=color:#66d9ef>print</span>(result)

<span style=color:#75715e>#------apply_async--------#</span>
all_task <span style=color:#f92672>=</span> []
<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>):
    <span style=color:#75715e># 进程池中维持processes=5个进程</span>
    all_task<span style=color:#f92672>.</span>append(pool<span style=color:#f92672>.</span>apply_async(f, (i,)))

pool<span style=color:#f92672>.</span>close()
pool<span style=color:#f92672>.</span>join()
<span style=color:#75715e># 结果</span>
result <span style=color:#f92672>=</span> []
<span style=color:#66d9ef>for</span> res <span style=color:#f92672>in</span> all_task:
    result<span style=color:#f92672>.</span>append(res<span style=color:#f92672>.</span>get())

</code></pre></div><table><thead><tr><th style=text-align:left>方法</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left>apply_async(func, args=())</td><td style=text-align:left>从进程池中取出一个进程执行func函数，args为该函数的参数，它将返回一个AsyncResult对象，可以用该对象的get()方法来获取结果。非阻塞</td></tr><tr><td style=text-align:left>close()</td><td style=text-align:left>进程池不能再创建新的进程</td></tr><tr><td style=text-align:left>join()</td><td style=text-align:left>wait进程池中的全部进程，必须对Pool先调用close()方法才能join</td></tr></tbody></table><h4 id=共享内存>共享内存</h4><p>可以使用<code>Value</code>或<code>Array</code>将数据存储在共享内存映射中</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> multiprocessing <span style=color:#f92672>import</span> Process, Value, Array

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>f</span>(n, a):
    n<span style=color:#f92672>.</span>value <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.1415927</span>
    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(a)):
        a[i] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>a[i]

<span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
    <span style=color:#75715e># d: 表示双精度浮点数据</span>
    <span style=color:#75715e># i: 表示有符号整数</span>
    num <span style=color:#f92672>=</span> Value(<span style=color:#e6db74>&#39;d&#39;</span>, <span style=color:#ae81ff>0.0</span>)
    arr <span style=color:#f92672>=</span> Array(<span style=color:#e6db74>&#39;i&#39;</span>, range(<span style=color:#ae81ff>10</span>))

    p <span style=color:#f92672>=</span> Process(target<span style=color:#f92672>=</span>f, args<span style=color:#f92672>=</span>(num, arr))
    p<span style=color:#f92672>.</span>start()
    p<span style=color:#f92672>.</span>join()

    <span style=color:#66d9ef>print</span>(num<span style=color:#f92672>.</span>value)
    <span style=color:#66d9ef>print</span>(arr[:])
<span style=color:#75715e># 结果</span>
<span style=color:#75715e># 3.1415927</span>
<span style=color:#75715e># [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</span>
</code></pre></div><h4 id=服务进程>服务进程</h4><p>Manager() 返回的管理器对象控制一个服务进程：用来保存Python对象并允许其他进程使用代理操作他们。利用Manager()可以通过共享进程的方法共享数据。<br>管理器支持的数据类型有：list、dict、Namespace、Lock、RLock、Semaphore、BoundedSemaphore、Condition、Event、Barrier、Queue、Value 和 Array</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> multiprocessing <span style=color:#f92672>import</span> Process,Manager
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>func1</span>(shareList,shareValue,shareDict,lock):
    <span style=color:#66d9ef>with</span> lock:
        shareValue<span style=color:#f92672>.</span>value<span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
        shareDict[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;1&#39;</span>
        shareDict[<span style=color:#ae81ff>2</span>]<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;2&#39;</span>
        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> xrange(len(shareList)):
            shareList[i]<span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>

<span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
    manager<span style=color:#f92672>=</span>Manager()
    list1<span style=color:#f92672>=</span>manager<span style=color:#f92672>.</span>list([<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>])
    dict1<span style=color:#f92672>=</span>manager<span style=color:#f92672>.</span>dict()
    array1<span style=color:#f92672>=</span>manager<span style=color:#f92672>.</span>Array(<span style=color:#e6db74>&#39;i&#39;</span>,range(<span style=color:#ae81ff>10</span>))
    value1<span style=color:#f92672>=</span>manager<span style=color:#f92672>.</span>Value(<span style=color:#e6db74>&#39;i&#39;</span>,<span style=color:#ae81ff>1</span>)
    lock<span style=color:#f92672>=</span>manager<span style=color:#f92672>.</span>Lock()
    proc<span style=color:#f92672>=</span>[Process(target<span style=color:#f92672>=</span>func1,args<span style=color:#f92672>=</span>(list1,value1,dict1,lock)) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> xrange(<span style=color:#ae81ff>20</span>)]
    <span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> proc:
        p<span style=color:#f92672>.</span>start()
    <span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> proc:
        p<span style=color:#f92672>.</span>join()
    <span style=color:#66d9ef>print</span> list1
    <span style=color:#66d9ef>print</span> dict1
    <span style=color:#66d9ef>print</span> array1
    <span style=color:#66d9ef>print</span> value1
<span style=color:#75715e># 结果</span>
<span style=color:#75715e># [21, 22, 23, 24, 25]</span>
<span style=color:#75715e># {1: &#39;1&#39;, 2: &#39;2&#39;}</span>
<span style=color:#75715e># array(&#39;i&#39;, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span style=color:#75715e># Value(&#39;i&#39;, 21)</span>

</code></pre></div><h3 id=2processpoolexecutor模块>2、<code>ProcessPoolExecutor模块</code></h3><p>ProcessPoolExecutor在使用上和ThreadPoolExecutor大致一样，在futures中的方法也是相同的，但对于map()方法，ProcessPoolExecutor会对一个参数<code>chunksize</code>，将迭代对象切成块，将其作为分开的任务提交给pool，对于很大的iterables，设置较大的chunksize可以提高性能。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> concurrent.futures <span style=color:#f92672>import</span> ProcessPoolExecutor, as_completed
<span style=color:#f92672>import</span> time

<span style=color:#75715e># 参数times用来模拟网络请求的时间</span>
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_html</span>(times):
    time<span style=color:#f92672>.</span>sleep(times)
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;get page {}s finished&#34;</span><span style=color:#f92672>.</span>format(times))
    <span style=color:#66d9ef>return</span> times

executor <span style=color:#f92672>=</span> ProcessPoolExecutor(max_workers<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
urls <span style=color:#f92672>=</span> [<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>] <span style=color:#75715e># 并不是真的url</span>

<span style=color:#75715e># 方法：as_completed</span>
all_task <span style=color:#f92672>=</span> [executor<span style=color:#f92672>.</span>submit(get_html, url) <span style=color:#66d9ef>for</span> url <span style=color:#f92672>in</span> urls]
<span style=color:#66d9ef>for</span> future <span style=color:#f92672>in</span> as_completed(all_task):
    data <span style=color:#f92672>=</span> future<span style=color:#f92672>.</span>result()
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;in main: get page {}s success&#34;</span><span style=color:#f92672>.</span>format(data))
<span style=color:#75715e># 执行结果</span>
<span style=color:#75715e># get page 2s finished</span>
<span style=color:#75715e># in main: get page 2s success</span>
<span style=color:#75715e># get page 3s finished</span>
<span style=color:#75715e># in main: get page 3s success</span>
<span style=color:#75715e># get page 4s finished</span>
<span style=color:#75715e># in main: get page 4s success</span>

<span style=color:#75715e># 方法：map</span>
<span style=color:#66d9ef>for</span> data <span style=color:#f92672>in</span> executor<span style=color:#f92672>.</span>map(get_html, urls):
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;in main: get page {}s success&#34;</span><span style=color:#f92672>.</span>format(data))

</code></pre></div></div><div class="row pl-3 pr-3"><div class="col-md-6 share-buttons"><strong>分享:</strong>
<a class="btn btn-sm facebook-btn" href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fbiubiobiu.github.io%2fzh-cn%2fposts%2f00035_programming_language%2f0035_python%2f0050_sdk_lib%2f0020_multiprocessing%2f" target=_blank><i class="fab fa-facebook"></i></a><a class="btn btn-sm twitter-btn" href="https://twitter.com/share?url=https%3a%2f%2fbiubiobiu.github.io%2fzh-cn%2fposts%2f00035_programming_language%2f0035_python%2f0050_sdk_lib%2f0020_multiprocessing%2f&text=%e5%b9%b6%e8%a1%8c%e6%93%8d%e4%bd%9c&via=biubiobiu%27s%20Blog" target=_blank><i class="fab fa-twitter"></i></a><a class="btn btn-sm reddit-btn" href="https://reddit.com/submit?url=https%3a%2f%2fbiubiobiu.github.io%2fzh-cn%2fposts%2f00035_programming_language%2f0035_python%2f0050_sdk_lib%2f0020_multiprocessing%2f&title=%e5%b9%b6%e8%a1%8c%e6%93%8d%e4%bd%9c" target=_blank><i class="fab fa-reddit"></i></a><a class="btn btn-sm linkedin-btn" href="https://www.linkedin.com/shareArticle?url=https%3a%2f%2fbiubiobiu.github.io%2fzh-cn%2fposts%2f00035_programming_language%2f0035_python%2f0050_sdk_lib%2f0020_multiprocessing%2f&title=%e5%b9%b6%e8%a1%8c%e6%93%8d%e4%bd%9c" target=_blank><i class="fab fa-linkedin"></i></a><a class="btn btn-sm whatsapp-btn" href="https://api.whatsapp.com/send?text=%e5%b9%b6%e8%a1%8c%e6%93%8d%e4%bd%9c https%3a%2f%2fbiubiobiu.github.io%2fzh-cn%2fposts%2f00035_programming_language%2f0035_python%2f0050_sdk_lib%2f0020_multiprocessing%2f" target=_blank><i class="fab fa-whatsapp"></i></a><a class="btn btn-sm email-btn" href="mailto:?subject=%e5%b9%b6%e8%a1%8c%e6%93%8d%e4%bd%9c&body=https%3a%2f%2fbiubiobiu.github.io%2fzh-cn%2fposts%2f00035_programming_language%2f0035_python%2f0050_sdk_lib%2f0020_multiprocessing%2f" target=_blank><i class="fas fa-envelope-open-text"></i></a></div></div><hr><div class="row next-prev-navigator"><div class="col-md-6 previous-article"><a href=/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0050_file/ title=文件读取 class="btn btn-outline-info"><div><i class="fas fa-chevron-circle-left"></i>上一篇</div><div class=next-prev-text>文件读取</div></a></div><div class="col-md-6 next-article"><a href=/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0030_importlib/ title=importlib包 class="btn btn-outline-info"><div>下一篇 <i class="fas fa-chevron-circle-right"></i></div><div class=next-prev-text>importlib包</div></a></div></div><hr></div></div></div><a id=scroll-to-top class=btn><i class="fas fa-chevron-circle-up"></i></a></section><section class=toc-section id=toc-section><div class=toc-holder><h5 class="text-center pl-3">目录</h5><hr><div class=toc><nav id=TableOfContents><ul><li><a href=#一线程与进程>一、线程与进程</a></li><li><a href=#二多线程>二、多线程</a><ul><li><a href=#1threading模块>1、<code>threading模块</code></a></li><li><a href=#2threadpoolexecutor线程池>2、<code>ThreadPoolExecutor线程池</code></a></li></ul></li><li><a href=#三多进程>三、多进程</a><ul><li><a href=#1multiprocessing模块>1、<code>multiprocessing模块</code></a><ul><li><a href=#多进程>多进程：</a></li><li><a href=#进程池process-pool>进程池(Process Pool)</a></li><li><a href=#共享内存>共享内存</a></li><li><a href=#服务进程>服务进程</a></li></ul></li><li><a href=#2processpoolexecutor模块>2、<code>ProcessPoolExecutor模块</code></a></li></ul></li></ul></nav></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>导航</h5><ul><li class=nav-item><a class=smooth-scroll href=https://biubiobiu.github.io/zh-cn/#about>关于</a></li><li class=nav-item><a class=smooth-scroll href=https://biubiobiu.github.io/zh-cn/#skills>技能</a></li><li class=nav-item><a class=smooth-scroll href=https://biubiobiu.github.io/zh-cn/#experiences>经验</a></li><li class=nav-item><a class=smooth-scroll href=https://biubiobiu.github.io/zh-cn/#projects>项目</a></li><li class=nav-item><a class=smooth-scroll href=https://biubiobiu.github.io/zh-cn/#education>教育</a></li><li class=nav-item><a class=smooth-scroll href=https://biubiobiu.github.io/zh-cn/#recent-posts>最新博客</a></li><li class=nav-item><a class=smooth-scroll href=https://biubiobiu.github.io/zh-cn/#accomplishments>造诣</a></li><li class=nav-item><a class=smooth-scroll href=https://biubiobiu.github.io/zh-cn/#achievements>业绩</a></li></ul></div><div class="col-md-4 col-sm-12"><h5>联系方式:</h5><ul><li><span>电话:</span> <span>+0123456789</span></li><li><span>邮箱:</span> <span>bsgshyn8@163.com</span></li></ul></div></div></div><hr><div class=container><p id=disclaimer><strong>免责声明:</strong> 这个主题是MIT许可的。因此，您可以将其用于非商业、商业或者私人用途。您可以修改或分发主题，而无须经 作者任何许可。但是，主题作者不对主题的任何问题提供任何保证或承担任何责任。</p></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hossainemruz/toha target=_blank rel=noopener><img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_2.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">© 2021 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script type=text/javascript src=/js/jquery-3.4.1.min.js></script><script type=text/javascript src=/js/popper.min.js></script><script type=text/javascript src=/js/bootstrap.min.js></script><script type=text/javascript src=/js/navbar.js></script><script type=text/javascript src=/js/plyr.js></script><script type=text/javascript src=/js/main.js></script><script type=text/javascript src=/js/darkreader.js></script><script type=text/javascript src=/js/darkmode-darkreader.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js></script><script src=/js/single.js></script><script>hljs.initHighlightingOnLoad();</script><link rel=stylesheet href=/katex/katex.min.css><script type=text/javascript defer src=/katex/katex.min.js></script><script type=text/javascript defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body);></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false},{left:'\\(',right:'\\)',display:false},{left:'\\[',right:'\\]',display:true}],throwOnError:false});});</script><script src=/js/mermaid-8.14.0.min.js></script><script>mermaid.initialize({startOnLoad:true});</script></body></html>