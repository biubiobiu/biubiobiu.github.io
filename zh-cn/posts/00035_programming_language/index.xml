<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程语言 on biubiobiu's Blog</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/</link><description>Recent content in 编程语言 on biubiobiu's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Everything is mine</copyright><lastBuildDate>Tue, 01 Aug 2023 06:00:20 +0800</lastBuildDate><atom:link href="https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/index.xml" rel="self" type="application/rss+xml"/><item><title>MySQL</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0070_hive/0010_sql/</link><pubDate>Tue, 01 Aug 2023 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0070_hive/0010_sql/</guid><description>一、数据类型</description></item><item><title>创建库/表</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0070_hive/0020_hive/0010_hive_build/</link><pubDate>Tue, 01 Aug 2023 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0070_hive/0020_hive/0010_hive_build/</guid><description>一、数据库操作 1、创建数据库 功能 操作 查看数据库 show databases; 使用like关键字模糊匹配，显示包含db_前缀的数据库名称 show databases like &amp;lsquo;db_*'; 使用数据库 create database dbname; 创建数据库 create database dbname; 通过location指定数据库路径 create database dbname location &amp;lsquo;path路径&amp;rsquo;; 给数据库添加描述信息 create database dbname comment &amp;lsquo;dbname描述信息&amp;rsquo;; 删除数据库 删除数据库，这种删除，需要将数据库中的表全部删除，才能删除数据库 drop database dbname; 或者 drop database if exists dbname; cascade 强制删除 drop database dbname cascade; 查看数据库的详细描述 desc database dbname; destribe database dbname; 二、表操作 功能 操作 创建表 CREATE TABLE 表名 删除表 drop table if exists 表名 添加列 alter table 表名 add columns (列名 string comment &amp;lsquo;解释&amp;rsquo;) 修改字段类型 alter table 表名 change column 原字段名称 现字段名称 数据类型</description></item><item><title>常用操作</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0070_hive/0020_hive/0030_hive_common/</link><pubDate>Tue, 01 Aug 2023 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0070_hive/0020_hive/0030_hive_common/</guid><description>常用功能 1、获取当前时间 from_unixtime(unix_timestamp(),&amp;#39;yyyy-MM-dd HH:mm:ss&amp;#39;) 2、多行合并为一行 select gid, concat_ws(&amp;#39;,&amp;#39;,collect_set(url)) from table group by gid; 3、一行拆多列 -- 1列 select gid, url from table lateral view explode(split(url_list, &amp;#39;,&amp;#39;))t as url -- 2列 select gid, url, url_flag from table lateral view posexplode(split(url_list, &amp;#39;,&amp;#39;))t1 as url_index, url lateral view posexplode(split(url_flag_list, &amp;#39;,&amp;#39;))t2 as url_flag_index, url_flag where url_index = url_flag_index; 4、添加行号 如果单纯想添加一个自增的行号，没有顺序要去的话，over（）里面可以空着
Select row_number() over() as rownum From table 5、窗函数 SELECT RANK () over (PARTITION BY SUBJECT ORDER BY score DESC) AS RANK, DENSE_RANK () over (PARTITION BY SUBJECT ORDER BY score DESC) AS DENSE_RANK, ROW_NUMBER () over (PARTITION BY SUBJECT ORDER BY score DESC) AS ROW_NUMBER FROM table; 6、条件语句 【nvl】</description></item><item><title>常见函数</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0070_hive/0020_hive/0020_hive_func/</link><pubDate>Tue, 01 Aug 2023 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0070_hive/0020_hive/0020_hive_func/</guid><description>1、数学计算 函数 说明 round(double d) &amp;ndash;返回double型d的近似值（四舍五入），返回bigint型； round(double d,int n) &amp;ndash;返回保留double型d的n位小数double型近似值（四舍五入）； floor(double d) &amp;ndash;返回&amp;lt;=d的最大bigint值； ceil(double d) &amp;ndash;返回&amp;gt;=d的最小bigint 值； ceiling(double d) &amp;ndash;返回&amp;gt;=d的最小bigint 值； rand() &amp;ndash;每行返回一个double型随机数； rand(int seed) &amp;ndash;每行返回一个double型随机数，整数seed是随机因子； exp(double d) &amp;ndash;返回e的 d幂次方，返回double型； ln(double d) &amp;ndash;以自然数为底d的对数，返回double型； log10(double d) &amp;ndash;以10为底d的对数，返回double型； log2(double d) &amp;ndash;以2为底d的对数，返回double型； log(double base,double d) &amp;ndash;以base为底d的对数，返回double型； pow(double d,double p) &amp;ndash;d的p次幂，返回double型； power(double d,double p) &amp;ndash;d的p次幂，返回double型； sqrt(double d) &amp;ndash;d的平方根，返回double型； bin(bigint i) &amp;ndash;二进制i的string类型； hex(bigint i) &amp;ndash;十六进制i的string类型； hex(string str) &amp;ndash;计算十六进制表达的str值； unhex(string i) &amp;ndash;hex(string str)的逆方法； conv(bigint num,int from_base,int to_base) &amp;ndash;将bigint类型的num从from_base进制转换成to_base进制，返回string类型； conv(string num,int from_base,int to_base) &amp;ndash;将string类型的num从from_base进制转换成to_base进制，返回string类型； abs(double d) &amp;ndash;计算double型d 的绝对值，返回double型； pmod(int i1,int i2) &amp;ndash;int型i1对 int型 i2取模，结果为int型； pmod(double d1,double d2) &amp;ndash;double型i1对double型 i2取模，结果为double型； sin(double d) &amp;ndash;返回d的正弦值，结果为double型； asin(double d) &amp;ndash;返回d的反正弦值，结果为double型； cos(double d) &amp;ndash;返回d 的余弦值，结果为double型； acos(double d) &amp;ndash;返回d的反余弦值，结果为double型； tan(double d) &amp;ndash;返回d的正切值，结果为double型； atan(double d) &amp;ndash;返回d的反正切值，结果为double型； degrees(double d) &amp;ndash;将弧度值d转换成角度值，结果为double型； radians(double d) &amp;ndash;将角度值d转换成弧度值，结果为double型； positive(int i) &amp;ndash;等价有效表达式是+i,返回i，结果为int型； positive(double d) &amp;ndash;等价有效表达式是+d，返回d,结果为double型； negative(int i) &amp;ndash;等价有效表达式是-i，返回i的负数，结果为int型； negative(double d) &amp;ndash;等价有效表达式是-i，返回d的负数，结果为double型； sign(double d) &amp;ndash;如果d是正数的话，则返回float型1.</description></item><item><title>数据类型</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0070_hive/0020_hive/0040_hive_datatype/</link><pubDate>Tue, 01 Aug 2023 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0070_hive/0020_hive/0040_hive_datatype/</guid><description>一、数组array 【语法】：
array(val1, val2, val3, ...) 【建表】
create table temp.array_demo( meiti array&amp;lt;string&amp;gt; comment &amp;#39;&amp;#39; ) row format delimited fields terminated by &amp;#39;\t&amp;#39; -- (字段与字段之间的分隔符) lines terminated by &amp;#39;\n&amp;#39; () collection items terminated by &amp;#39;,&amp;#39; -- (必须使用, 一个字段中各个item的分割符) lacation &amp;#39;hdfs 路径&amp;#39; 【查询方法和函数】
-- 在字段类型为array中查找是否包含某元素 array_contains() -- 数组名[index]：查询 二、map 函数 说明 size(Map) map的长度 map_keys(Map) map中的所有key，返回array map_values(Map) map 中所有的value，返回array 【构建Map】 组装数据：to_json, str_to_map str_to_map(concat_ws(&amp;quot;,&amp;quot;, collect_set(concat_ws(':', date_key, price_value)))) 【构建Map】 聚合：combine；聚合去重：combine_unique combine(map1, map2, map3, &amp;hellip;) 【构建Map】 hive 自带方法 map(&amp;ldquo;key1&amp;rdquo;, value1, &amp;ldquo;key2&amp;rdquo;, value2) named_struct(&amp;ldquo;cnt&amp;rdquo;, 100, &amp;ldquo;uds&amp;rdquo;, array(2, 3, 4))</description></item><item><title>正则匹配</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0070_hive/0020_hive/0050_hive_regular/</link><pubDate>Tue, 01 Aug 2023 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0070_hive/0020_hive/0050_hive_regular/</guid><description/></item><item><title>Tensor和变量</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0050_pytorch/0040_tensor/</link><pubDate>Fri, 08 Apr 2022 06:00:20 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0050_pytorch/0040_tensor/</guid><description>Tensor
每个张量Tensor都有一个相应的torch.Storage，用来保存数据。
torch.Storage: 是一个单一数据类型的连续一维数组。每个Tensor都有一个对应的相同数据类型的存储：class torch.FloatStorage 类tensor：提供了一个存储 多维的、横向视图，并定义了数值运算。 torch.Tensor.abs()：会在原地计算，并返回改变后的tensor
torch.Tensor.abd()：在一个新的tensor中计算结果 变量
Variable 在torch.autograd.Variable中，Variable的结构图：data：Variable的tensor数值 grad_fn：表示得到这个Variable的操作，
grad：表示Variable的反向传播梯度 示例1：x = Variable(torch.Tensor([1]), requires_grad=Ture) 其中：requires_grad=True ：这个参数表示是否对这个变量求梯度。
x.backward()：自动求导。自动求导不需要再去明确地写明那个函数对那个函数求导，直接通过这行代码就可以对所有的需要梯度的变量进行求导。
x.grad：存放的就是x的梯度值 示例2：y.backward(torch.FloatTensor([1,0.1,0.01]))，表示得到的梯度分别乘以1,0.1,0.01 Variable和Tensor本质上没有区别，不过Variable会被放入一个计算图中，然后进行前向传播、反向传播、自动求导。 tensor与Variable之间的转换： tensor —to—&amp;gt; Variable：b=Variable(a) 一、Tensor信息 torch.is_tensor(obj) 判断是否为tensor torch.is_storage(obj) 判断obj是一个pytorch storage对象 torch.set_default_tensor_type() torch.numel(Tensor) 返回张量中元素的个数 二、创建Tensor torch.Tensor([[1,2],[3,4]])。创建&amp;mdash;返回指定数值的张量 torch.randn(*sizes, out=None)。创建&amp;mdash;返回标准正态分布的随机数张量。标准正态分布，形状由sizes定义 torch.randperm(n, out=None)。创建&amp;mdash;返回0~n-1之间的随机整数1维张量。返回一个从0~n-1的随机整数排列 torch.rand(*sizes, out=None)。创建&amp;mdash;返回[0, 1)的均匀分布张量 torch.arange(start, end, step=1, out=None)。创建&amp;mdash;返回一个1维张量。[start, end) 以step为步长的一组序列值 torch.range(start, end, step=1, out=None)。创建&amp;mdash;返回一个1维张量。[start, end) 以step为步长的1维张量 torch.zeros(*sizes, out=None)。创建&amp;mdash;返回一个全为0的张量。生成一个tensor, 数值为0，形状由sizes定义 torch.</description></item><item><title>基础操作</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0050_pytorch/0020_basic/</link><pubDate>Fri, 08 Apr 2022 06:00:20 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0050_pytorch/0020_basic/</guid><description>一、数据类型 1、torch的数据类型 torch.Tensor 是默认的torch.FloatTensor 的简称。
剥离出一个Tensor参与计算，不参与求导：Tensor后加 .detach()
各个数据类型之间的转换：
方法一：在Tensor后加，.long(), .int(), .float(), .double() 方法二：可以用 .to()函数 数据类型 CPU tensor GPU tensor 32-bit float torch.FloatTensor torch.cuda.FloatTensor 64-big float torch.DoubleTensor torch.cuda.DoubleTensor 16-bit float N/A torch.cuda.HalfTensor 8-bit integer(unsigned) torch.ByteTensor torch.cuda.ByteTensor 8-bit integer(signed) torch.CharTensor torch.cuda.CharTensor 16-bit integer(signed) torch.ShortTensor torch.cuda.ShortTensor 32-bit integer(signed) torch.IntTensor torch.cuda.IntTensor 64-bit integer(signed) torch.</description></item><item><title>数学计算</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0050_pytorch/0030_mathematical/</link><pubDate>Fri, 08 Apr 2022 06:00:20 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0050_pytorch/0030_mathematical/</guid><description>一、数学计算 torch.abs(input)。 数学&amp;mdash;绝对值 torch.add(input, value)。数学&amp;mdash;对张量的每个元素加value值 torch.div(input, value)。数学&amp;mdash;逐元素除法，将input逐元素除以标量value torch.div(input, other)。数学&amp;mdash;逐元素除法。
两个张量input和other逐元素相除.这两个维度可以不同，但元素数量一定要一致。输出: 与input维度一致 torch.mul(input, value)。数学&amp;mdash;逐元素乘法 torch.mul(input, other)。数学&amp;mdash;逐元素乘法 torch.fmod(inpur, divisor, out)。数学&amp;mdash;取余 torch.remainder(input, divisor, out)。数学&amp;mdash;取余 相当于 %。
divisor: 标量或者张量 逐元素 torch.addcdiv(tensor, value=1, tensor1, tensor2, out=None)。数学&amp;mdash; 像素点相除后相加。
out = tensor .+ value*(tensor1./tensor2) torch.addcmul(tensor, value=1, tensor1, tensor2, out=None)。数学&amp;mdash; 像素点相乘后相加。
out = tensor .+ value*(tensor1 .* tensor2) torch.neg(input)。数学&amp;mdash;取负。out = -1 * input。 torch.reciprocal(input)。数学&amp;mdash;倒数。out = 1.0 / input。 torch.sign(input)。数学&amp;mdash;取正负符号 torch.sin(Tensor)。数学&amp;mdash;正弦 torch.cos(Tensor)。数学&amp;mdash;余弦 torch.tan(Tensor)。数学&amp;mdash;正切 torch.sinh(Tensor)。数学&amp;mdash;双曲正弦 torch.cosh(Tensor)。数学&amp;mdash;双曲余弦 torch.tanh(Tensor)。数学&amp;mdash;双曲正切 torch.asin(Tensor)。数学&amp;mdash;反正弦 torch.acos(input)。数学&amp;mdash;反余弦 torch.</description></item><item><title>模型训练</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0050_pytorch/0050_train_model/</link><pubDate>Fri, 08 Apr 2022 06:00:20 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0050_pytorch/0050_train_model/</guid><description>一、数据预处理 import torch from torch.utils.data import Dataset, DataLoader, TensorDataset from torch.autograd import Variable import numpy as np class MyDataset(Dataset): &amp;#34;&amp;#34;&amp;#34; 下载数据、初始化数据，都可以在这里完成 &amp;#34;&amp;#34;&amp;#34; def __init__(self): xy = np.loadtxt(&amp;#39;../dataSet/diabetes.csv.gz&amp;#39;, delimiter=&amp;#39;,&amp;#39;, dtype=np.float32) # 使用numpy读取数据 self.x_data = torch.from_numpy(xy[:, 0:-1]) self.y_data = torch.from_numpy(xy[:, [-1]]) self.len = xy.shape[0] def __getitem__(self, index): return self.x_data[index], self.y_data[index] def __len__(self): return self.len # 创建Dataset对象 dataset = MyDataset() # 创建DataLoadder对象 dataloader = DataLoader(dataset, batch_size=32, shuffle=True, num_workers=2) # 循环DataLoader对象 num_epoches = 100 for epoch in range(num_epoches) for img, label in dataloader: # 将数据从dataloader中读取出来，一次读取的样本数为32个 # class torch.</description></item><item><title>正则</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0050_re/</link><pubDate>Wed, 08 Dec 2021 16:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0050_re/</guid><description>一、字符 字符 中文-简体 \u4e00-\u9fa5 中文-繁体 \u9fa6-\u9fff 日文 \u3040-\u30fa 韩文 \uac00-\ud7ff 二、 三、</description></item><item><title>cuda</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0010_build_env/0020_cuda_env/</link><pubDate>Wed, 08 Dec 2021 16:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0010_build_env/0020_cuda_env/</guid><description>一、简介 1、CUDA CUDA：英伟达开发的一个通用并行计算平台和编程模型，能让你调用GPU的指令集及其并行计算单元。基于cuda编程可以利用GPU的并行计算引擎来更高效地计算。
特点：
GPU有更多的计算核心，适合数据并行的计算密集型任务。 CPU有较少的运算核心，适合实现复杂的逻辑计算，用于控制密集型任务。 对比一下： CPU &amp;ndash; 线程是重量级的，上下文切换开销较大。 负责处理逻辑复杂的串行程序 GPU &amp;ndash; 由于存在较多核心，线程是轻量级的。负责处理数据密集型的并行机选程序 2、CUDA编程模型 CUDA编程模型是一个异构模型，需要CPU和GPU协同工作，在CUDA中有两个重要的概念：host和device。
host: CPU + 其内存
device: GPU + 其内存
典型的CUDA程序的执行流程：
分配host内存，并进行数据初始化 分配device内存，并从host将数据copy到device上 调用CUDA的核函数在device上完成指定的运算 将device上的运算结果copy到host上 释放device和host上分配的内存。 3、cuDNN cuDNN: CUDA Deep Neural Network软件库，是一个用于深度神经网络的GPU加速原语库。
TensorRT: 是一套用于高性能深度学习接口的SDK，其包含深度学习接口优化器、运行时优化器，能为深度学习接口提供低延迟和高通量的特性。
二、CUDA安装 1、驱动安装 NVIDIA驱动
关键点：CUDA和显卡驱动没有一一对应的关系，一般情况下安装最新的驱动。
2、CUDA安装 CUDA下载
CUDA: 只是一个工具包，在同一设备上可以安装多个不同的版本，比如：9.0，10.0，11.0。一般情况下安装最新的驱动，然后根据自己的需求选择不同CUDA工具包就行了。但在离线安装CUDA时会绑定CUDA和驱动程序，所以在使用多个CUDA的时候就不要选择离线安装CUDA了。
安装步骤:
不用选择太高的cuda版本，太高反而兼容性不好，要兼顾Tensorflow等架构的版本 安装包下载后，一路默认安装就好。检查是否安装成功：nvcc -V cuda的安装包中包含NVIDIA驱动，安装时取消勾选安装驱动，只安装工具包就行 CUDA安装后，配置环境变量：
CUDA10.1是之前安装的，CUDA11.1是之后安装的，所以默认CUDA10.1的环境变量在CUA11.1之前，CUDA_PATH环境变量被CUDA11.1覆盖
CUDA版本切换：
切换CUDA版本时，只需要切换环境变量中CUDA的顺序即可，比如让CUDA11.1生效，则CUDA11.1环境变量在CUDA10.1之前。
3、cuDNN安装 cuDNN下载
cuDNN：是一个SDK，是一个专门用于神经网路的加速包，它跟CUDA没有一一对应的关系。即：每个CUDA版本可能有好几个cuDNN版本，一般有一个最新版本的cuDNN版本与CUDA对应更好。
安装步骤：
根据cuda版本选择对应的cudnn版本；不同系统，选择不同的型号。 下载的不是安装包，而是压缩文件，解压后将对应的文件拷贝到cuda安装路径对应的目录中。默认安装的路径： 复制 cudnn\bin\cudnn64_5.</description></item><item><title>ipdb包</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0040_ipdb/</link><pubDate>Wed, 08 Dec 2021 16:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0040_ipdb/</guid><description>一、ipdb 断点调试：
n(next) 下一条语句 s(step into) 进入函数调用的内部 b line_number(break) 给指定的行号位置加断点 c(continue) 给指定的文件（还没执行到的代码）中指定行号位置，打断点 r(return) 一直执行到下一个断点 j line_numver(jump) 可以跳过某段代码，直接执行指定行号所在的代码 cl(clear) 清楚断点，如果没有参数，则清除所有断点 restart 重新启动调试器 l first/second(list) 在ipdb调试环境中，默认只显示当前执行的代码行，以及上下各一行的代码，如果想要看到更多的上下文代码，可以使用该命令 w(where) 调试时可能会忘记自己目前做在的行号，可以使用w打印目前所在的行号位置，以及上下文信息 whatis variable_name 查看变量的类别，感觉有点鸡肋，用type也可以 a(argument) 当处于一个函数内部的时候，可以使用a打印传入函数的所有参数的值 p variable_name(print) 打印表达式的值 q 退出调试，并清楚所有信息</description></item><item><title>logging</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0080_logging/</link><pubDate>Wed, 08 Dec 2021 16:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0080_logging/</guid><description>一、logging模块 logging模块是Python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、日志保存路径、日志文件回滚等；相比print，具备如下优点：
可以通过设置不同的日志等级，在release版本中只输出重要信息，而不必显示大量的调试信息； print将所有信息都输出到标准输出中，严重影响开发者从标准输出中查看其它数据；logging则可以由开发者决定将信息输出到什么地方，以及怎么输出； logging模块与log4j的机制是一样的，只是具体的实现细节不同。模块提供logger，handler，filter，formatter。
logger：提供日志接口，供应用代码使用。logger最长用的操作有两类：配置和发送日志消息。可以通过logging.getLogger(name)获取logger对象，如果不指定name则返回root对象，多次使用相同的name调用getLogger方法返回同一个logger对象。 handler：将日志记录（log record）发送到合适的目的地（destination），比如文件，socket等。一个logger对象可以通过addHandler方法添加到多个handler，每个handler又可以定义不同日志级别，以实现日志分级过滤显示。 filter：提供一种优雅的方式决定一个日志记录是否发送到handler。 formatter：指定日志记录输出的具体格式。formatter的构造方法需要两个参数：消息的格式字符串和日期字符串，这两个参数都是可选的。 与log4j类似，logger，handler和日志消息的调用可以有具体的日志级别（Level），只有在日志消息的级别大于logger和handler的级别。
import logging # logger = logging.getLogger(__name__) logger.setLevel(level = logging.INFO) # 创建一个FileHandler handler = logging.FileHandler(&amp;#39;log.txt&amp;#39;) # 设置等级: DEBUG &amp;lt; INFO &amp;lt; WARNING &amp;lt; ERROR &amp;lt; CRITICAL，而日志的信息量是依次减少的 handler.setLevel(logging.INFO) # 设置输出消息的格式 formatter = logging.Formatter(&amp;#39;%(asctime)s- %(name)s- %(levelname)s- %(message)s&amp;#39;) handler.setFormatter(formatter) # 添加到logger中 logger.addHandler(handler) # 写入消息 logger.info(&amp;#34;Hello&amp;#34;) 二、消息格式 输出消息的格式 解释 %(levelno)s 打印日志级别的数值 %(levelname)s 打印日志级别的名称 %(pathname)s 打印当前执行程序的路径，其实就是sys.</description></item><item><title>OpenCV</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0110_opencv/</link><pubDate>Wed, 08 Dec 2021 16:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0110_opencv/</guid><description>安装问题：在环境里安装OpenCV后，在pycharm上没有命令提示。这个可能是OpenCV版本的问题。
解决方案：python3 -m pip install &amp;ndash;force-reinstall &amp;ndash;no-cache -U opencv-python==4.5.5.62
一、连通域 cv2.connectedComponentsWithStats 示例：num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(image, connectivity=8, ltype=None)
输入参数：
* image: 二值图
* connectivity：可选值为4或者8，表示使用4联通还是8联通
* ltype：输出图像标记的类型，目前支持CV_32S、CV_16U
输出参数：
* num_labels: 所有连通域的数目
* labels：图像上每个像素的标记
* stats：每个标记的统计信息：是一个5列的矩阵[[x,y,width,height,面积]，]
* centroids：连通域的中心点
cv2.connectedComponents 示例：num_objects, labels = cv2.connectedComponents(image)
输入参数：
* image: 二值图，8bit单通道图像
输出参数：
* num_labels: 所有连通域的数目
二、画图</description></item><item><title>PIL</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0100_pil/</link><pubDate>Wed, 08 Dec 2021 16:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0100_pil/</guid><description>一、PIL模块 PIL: Python Imaging Library 已经是python平台上的图像处理的标准库了，PIL功能非常强大。由于PIL仅支持python2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，名字叫Pillow，支持最新Python3.x，又加入了许多新特征。
from PIL import Image 操作 解释 Image.fromarray() 从一个numpy对象转换为一个PIL image对象 img = Image.open(&amp;lsquo;test.jpg&amp;rsquo;) 打开一个图像文件，返回值img是一个PIL图像对象。PIL是个足够智能的类库，可以根据文件扩展名来判断图像的格式。 img.save(&amp;lsquo;路径&amp;rsquo;) PIL会根据文件扩展名来判断图像的格式，如果图像文件不是该格式，会自动将其转换为该格式。 img.thumbnail((h,w)) 创建图像的缩略图, thumbnail()方法接受一个元组参数, 指定生成缩略图的尺寸. 然后将图像转换成指定尺寸的缩略图. region = img.crop((左, 上, 右, 下)) 裁剪指定区域 region = region.transpose(Image.ROTATE_180)
img.paste(region, (左,上,右,下)) 旋转180，然后将该区域放回去 img.resize((h, w)) 调整图像尺寸, resize()方法的参数是一个元组, 用来指定新图像的尺寸 img.rotate(45) 逆时针旋转图像</description></item><item><title>argparse</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0090_argparse/</link><pubDate>Wed, 08 Dec 2021 16:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0090_argparse/</guid><description>一、argparse模块 import argparse # 创建ArgumentParser()解析对象 parser = argparse.ArgumentParser() # 使用add_argument()方法，添加参数 parser.add_argument(&amp;#39;--integer&amp;#39;, type=int, default=0, help=&amp;#39;displayas integer&amp;#39;) parser.add_argument(&amp;#39;--string&amp;#39;, type=str, default=&amp;#39;&amp;#39;, help=&amp;#39;displayas string&amp;#39;) args = parser.parse_args() add_argument 的参数：
name or flags - 选项字符串的名字或者列表，例如 foo 或者 -f, &amp;ndash;foo。 action - 命令行遇到参数时的动作，默认值是 store。 store_const，表示赋值为const； append，将遇到的值存储成列表，也就是如果参数重复则会保存多个值; append_const，将参数规范中定义的一个值保存到一个列表； count，存储遇到的次数；此外，也可以继承 argparse.Action 自定义参数解析； nargs - 应该读取的命令行参数个数，可以是具体的数字，或者是?号，当不指定值时对于 Positional argument 使用 default，对于 Optional argument 使用 const；或者是 * 号，表示 0 &amp;gt; 或多个参数；或者是 + 号表示 1 或多个参数。 const - action 和 nargs 所需要的常量值。 default - 不指定参数时的默认值。 type - 命令行参数应该被转换成的类型。 choices - 参数可允许的值的一个容器。 required - 可选参数是否可以省略 (仅针对可选参数)。 help - 参数的帮助信息，当指定为 argparse.</description></item><item><title>requests</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0070_request/</link><pubDate>Wed, 08 Dec 2021 16:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0070_request/</guid><description>一、request模块 requests模块：在python内置模块上进行了高度的封装，使得requests更方便。
url: uniform resource locator，统一资源定位符：互联网上标准资源的地址。
格式：
模式/协议，比如：https、http 服务器名称(或者IP地址)，比如：api.github.com 路径和文件名，比如：events requests.get(url) get请求 &amp;mdash; 不带参数 requests.get(url, params={&amp;ldquo;参数1&amp;rdquo;:&amp;ldquo;值1&amp;rdquo;}) get请求 &amp;mdash; 带参数 requests.get(url, headers=header, cookie=cookie) header = {&amp;ldquo;content-type&amp;rdquo;: &amp;ldquo;application/json&amp;rdquo;,&amp;ldquo;user-agent&amp;rdquo;: &amp;ldquo;&amp;quot;} 定制headers requests.get(url, proxies=proxies) proxies = {&amp;ldquo;http&amp;rdquo;: &amp;ldquo;ip1&amp;rdquo;, &amp;ldquo;https&amp;rdquo;: &amp;ldquo;ip2&amp;rdquo;} 代理 requests.post(url, data=json.dumps({&amp;quot;&amp;quot;:&amp;quot;&amp;quot;})) post请求 requests.</description></item><item><title>堆-heapq</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0060_heapd/</link><pubDate>Wed, 08 Dec 2021 16:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0060_heapd/</guid><description>一、堆 import heapq 操作 解释 功能 例如：arr=[2, 9, 1, 4] heapq.heapify(arr) 建堆，对列表arr建堆。
也可以这样：
arr = [(5, &amp;lsquo;a&amp;rsquo;), (2, &amp;lsquo;b&amp;rsquo;), (8, &amp;lsquo;c&amp;rsquo;), (9, &amp;rsquo;d'), (6, &amp;lsquo;e&amp;rsquo;), (1, &amp;lsquo;f&amp;rsquo;)]
heapq.heapify(arr) 然后arr就变成：
[(1, &amp;lsquo;f&amp;rsquo;), (2, &amp;lsquo;b&amp;rsquo;), (5, &amp;lsquo;a&amp;rsquo;), (9, &amp;rsquo;d'), (6, &amp;lsquo;e&amp;rsquo;), (8, &amp;lsquo;c&amp;rsquo;)]
建堆 heapq.heappush(arr, 10) 添加元素，然后再向上调整堆。例如：在arr列表中添加5，然后在维持一个堆 添加 heapq.heappop(arr, 10) 提取堆顶，然后把堆尾放在堆顶，最后对堆顶做向下调整。把arr的堆顶元素提取出来。 pop heapq.heappushpop(arr, 10) 用新元素与堆顶做比较，如果堆顶大于新元素，直接返回新元素。否则返回堆顶，并把新元素放在堆顶后向下调整 heapq.</description></item><item><title>py-env</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0010_build_env/0010_pip_env/</link><pubDate>Wed, 08 Dec 2021 16:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0010_build_env/0010_pip_env/</guid><description>一、anaconda环境 清华镜像源
可以通过从页面上下载，直接安装 可以是命令 wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2022.10-MacOSX-x86_64.sh sh Anaconda3-2022.10-MacOSX-x86_64.sh 配置环境变量：export PATH=~/anaconda3/bin:$PATH 操作 说明 conda config --show 查看配置 conda config --add channels 网址 添加源
conda config &amp;ndash;add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config &amp;ndash;add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
conda config &amp;ndash;set show_channel_urls yes conda info -e 查看conda的虚拟环境 conda list 查看该环境下，已经安装的包-版本 conda search 包名 查看安装包，是否可通过conda安装 安装 conda install -n 环境名 包名</description></item><item><title>importlib包</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0030_importlib/</link><pubDate>Wed, 08 Dec 2021 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0030_importlib/</guid><description>import_module()函数 背景：一个函数运行，需要根据不同项目的配置，动态导入对应的配置文件。 例如：如下路径，向a模块中导入c.py中的对象 a
├── a.py
├── __init__.py
b
├── b.py
├── c │　├── c.py　# 该文件中，有变量args=[]，class C
│　├── __init__.py
方案：
import importlib # 导入 params = importlib.import_module(&amp;#34;b.c.c&amp;#34;) # 对象中取出需要的对象 params.args # 取出变量 params.C # 取出类C</description></item><item><title>简介</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0050_pytorch/0010_torch_summary/</link><pubDate>Wed, 08 Sep 2021 06:00:20 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0050_pytorch/0010_torch_summary/</guid><description>官方文档
torch目录下，树状图:
├── quasirandom.py
├── random.py random模块
├── serialization.py
├── storage.py
├── tensor.py Tensor模块
├── functional.py
│
├── cuda
│　├── comm.py
│　├── error.py
│　├── memory.py
│　├── nccl.py
│　├── nvtx.py
│　├── profiler.py
│　├── random.py
│　├── sparse.py
│　└── streams.py
│
├── nn
│　├── backends
│　├── cpp.py
│　├── functional.py
│　├── grad.py
│　├── init.py
│　├── intrinsic
│　│　├── modules</description></item><item><title>NdArray使用</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0060_mxnet/0010_ndarray/0010_ndarray_summary/</link><pubDate>Wed, 08 Sep 2021 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0060_mxnet/0010_ndarray/0010_ndarray_summary/</guid><description>一、查阅文档 怎么查阅相关文档？ 官网
1. 查阅模块里的所有函数和类 from mxnet import nd print(dir(nd.random)) __开头和结尾的函数 (python的特别对象) 可以忽略 _开头的函数 (一般为内部函数) 可以忽略 其余成员，可以根据名字 大致猜出是什么意思。 2. 查阅特定函数和类的使用 想了解某个函数或者类的具体用法，可以使用help函数。以NDArray中的ones_like函数为例。
help(nd.ones_like) 注意：
jupyter记事本里，使用?来将文档显示在另外一个窗口中。例如：nd.ones_like? 与 help(nd.ones_like)效果一样。nd.ones_like??会额外显示该函数实现的代码。 二、内存开销 原始操作 首先来个例子：Y = Y + X &amp;ndash;&amp;gt; 每个操作会新开内存来存储运算结果。 上例中，X，Y 变量首先存储在内存中，相加的计算结果会另外开辟内存来存储；然后变量Y在指向新的内存。 内存使用情况：
内存id_x &amp;lt;&amp;ndash; X 内存id_y &amp;lt;&amp;ndash; Y 内存id_x+y &amp;lt;&amp;ndash; Y
Y[:] = X + Y 或者 Y += X 通过[:]把X+Y的结果写进Y对应的内存中。上述操作中，需要另外开辟内存来存储计算结果。 内存使用情况： 内存id_x &amp;lt;&amp;ndash; X 内存id_y &amp;lt;&amp;ndash; Y 内存id_x+y &amp;ndash;&amp;gt; 把内存id_x+y中数值复制到内存id_y中</description></item><item><title>内置模块</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0025_internal_module/</link><pubDate>Wed, 08 Sep 2021 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0025_internal_module/</guid><description>一、os os.path.basename() os.path.dirname() os.path.join() os.path.exists() os.path.isfile() os.path.isdir() os.path.abspath(__file__) 获取当前执行文件的绝对路径 os.listdir() 遍历该目录下的文件，返回文件名列表 os.walk() 遍历该目录，返回的是一个三元组(root, dirs, files)
root: 指的是当前正在遍历的文件夹的地址
dirs: 是一个list，内容是该文件夹中所有的目录的名字，不包括子目录
files：内容是该文件夹中所有的文件，不包括子目录 os.makedirs() 创建文件夹 os.remove() 删除文件夹 os.environ() 获取环境变量，比如：os.environ(&amp;lsquo;变量名&amp;rsquo;, &amp;lsquo;默认值&amp;rsquo;) 二、sys sys.</description></item><item><title>基础操作</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0020_basic_operator/</link><pubDate>Wed, 08 Sep 2021 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0020_basic_operator/</guid><description>一、数据类型与操作 操作 说明 del A[i] 删除列表A中下标为i的元素，其后的每个元素都前移一个位置 列表-删除 A.pop() 弹出列表尾部元素，相当于出栈 列表-删除 A.pop(i) 弹出列表中任何位置出的元素 列表-删除 A.remove('a') 有时候不知道索引号，只知道要删除的值；remove只删除第一个指定的值 列表-删除 A.sort(reverse=True) 对列表A从大到小排序，列表A被永久改变 列表-排序 B=sorted(A) 排序后，A没有被改变 列表-排序 A.reverse() A列表被永久的翻转了一下 列表-翻转 ord() 获取字符的ASCII码，比如：两个字符相减：ord(&amp;lsquo;a&amp;rsquo;) - ord(&amp;lsquo;b&amp;rsquo;) 二、*和**的作用 * 在函数定义/调用时的应用
在函数定义时：*让python创建一个名为topping的空元组，并将收到的所有值封装在这个元组中。 def make_pizza(size, *topping): # 定义 .</description></item><item><title>字符编码</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0010_encode_mode/</link><pubDate>Wed, 08 Sep 2021 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0010_encode_mode/</guid><description>一、字符编码 ASCII：计算机是美国人发明的，所以最早只考虑了简单的26个字母和一些控制字符，所以只用7-bit组合出128个组合，编号0~127，存储的时候凑成了一个byte。这个组合没有考虑其他国家，比如汉字就不只128个，于是中国为汉字编码发明了GB2312编码，其他国家也有自己的各种编码，互不兼容。
为了统一，提出了unicode编码，包含了各个国家的文字，对每个字符都用2个byte来表示，英文的话就在前面加0。
unicode对于英文就会有些浪费，为了解决这个问题，为了节约硬盘空间/ 网络带宽，又发明了utf-8编码，1个字符可能会被编码成1~6个字节，英文还是1个字节，汉字变成了3个字节，只有在生僻字才会在4个字节。
字符 ASCII unicode utf-8 A 01000001 00000000 01000001 01000001 中 01001110 00101101 11100100 10111000 10101101 字符应用层的形式 字符在内存的形式 字符在硬盘/网络中的形式 二、解析/转换 图片在网络中获取下来是二进制的格式(bytes)；或者通过 open('***.jpg', &amp;lsquo;rb&amp;rsquo;) 读取的图片也是二进制的格式
bytes格式 &amp;lt;-&amp;gt; str
bytes: 是(二进制)数字序列，是utf-8的编码形式。该格式的变量是不可修改的。 str &amp;ndash;&amp;gt; bytes : 使用str.encode()方法 bytes &amp;ndash;&amp;gt; str : 使用bytes.decode()方法 bytearray(): 该格式的变量是可以修改的 a = &amp;#39;人生苦短&amp;#39; # 此时b的格式是bytes，是不能修改的，即不能操作：b[:6] = &amp;#39;生命&amp;#39;.</description></item><item><title>并行操作</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0020_multiprocessing/</link><pubDate>Wed, 08 Sep 2021 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0050_sdk_lib/0020_multiprocessing/</guid><description>一、线程与进程 进程 线程 进程：是一个应用程序在处理机上的一次执行过程，是具有一定独立功能的程序在某数据集上的一次运行，是一个动态的概念。进程是系统进行资源分配和调度的独立单位。 线程：是进程中的一个实体，是CPU调度和分派的基本单位，线程自己基本上不拥有系统资源，它与同属于一个进程内的其他线程共享进程的全部资源。 地址空间 进程有自己独立的地址空间 进程中至少有一个线程，它们共享进程的地址空间 资源 进程是资源分配和拥有的单位 进程内的多个线程共享进程的资源 调度 线程是进程内的一个执行单元，也是进程内的可调度实体，也是处理器调度的基本单位 二、多线程 1、threading模块 python主要是通过thread和threading这两个模块来实现多线程，thread模块是比较底层的模块，threading模块是对thread做了一些封装，使用更方便。但是由于GIL的存在，无法使用threading充分利用CPU资源，如果想充分发挥多核CPU的计算能力，需要使用multiprocessing模块
python 3.x 已经摒弃了python 2.x中采用函数式thread模块来产生线程的方式。而是通过threading模块创建新的线程：
通过threading.Thread(Target=可执行方法)
import threading pro_list = [] mult_image_label_list = [] for index, img_list in enumerate(mult_image_label_list): # 创建线程 t1 = threading.Thread(target=函数名, args=(index, img_list)) pro_list.append(t1) for thread in pro_list: # 将线程设置为保护线程，否则会被无限挂起。 thread.setDaemon(True) thread.</description></item><item><title>异常</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0040_error/</link><pubDate>Wed, 08 Sep 2021 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0040_error/</guid><description>一、异常名称 异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 SystemExit Python 解释器请求退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 KeyboardInterrupt 用户中断执行(通常是输入^C) LookupError 无效数据查询的基类 IndexError 序列中没有没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode 相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告</description></item><item><title>文件读取</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0050_file/</link><pubDate>Wed, 08 Sep 2021 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0050_file/</guid><description>一、pandas import pandas as pd import pickle # 使用pandas对pickle进行操作 df = pd.DataFrame(np.arange(20).reshape(4, 5)) 操作 解释 pickle.load() pickle.dump() pd.DataFrame() df.to_pickle('**.pkl') to_pickle() 属性可以生成pickle文件，对数据进行永久存储 df.read_pickle('**.pkl') 从存储的pkl文件中，读取pickle数据 df.head(5) 查看前几行的数据，默认是前5行 df.tail(5) 查看后几行的数据，默认是前5行 df.values 查看DataFrame里的数据，返回是一个数组 df.iloc[k] 查看某一行的数据， df.shape 查看行列数 df[&amp;lsquo;a&amp;rsquo;:&amp;lsquo;b&amp;rsquo;] 切片，是表示的行切片 df.loc[:, &amp;lsquo;A&amp;rsquo;:&amp;lsquo;B&amp;rsquo;] 索引，表示的是列索引 df.</description></item><item><title>模型训练</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0040_tf/w0010_compat/0020_tf_compat_train/</link><pubDate>Wed, 08 Sep 2021 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0040_tf/w0010_compat/0020_tf_compat_train/</guid><description>一、tf.layers tf.layers模块在TensorFlow2.0中已经被完全移除了，用tf.keras.layers定义层是新的标准。
二、tf.losses tf.losses模块包含了经常使用的、能够实现独热编码的损失函数。
三、tf.train 1. Optimizer TensorFlow提供的优化器
优化器 功能 tf.train.Optimizer tf.train.GradientDescentOptimizer tf.train.AdadeltaOptimizer tf.train.AdagtadOptimizer tf.train.AdagradDAOptimizer tf.train.MomentumOptimizer tf.train.AdamOptimizer tf.train.FtrlOptimizer tf.train.ProximalGradientDescentOptimizer tf.train.ProximalAdagradOptimizer tf.train.RMSProOptimizer Optimizer类与其子类的继承关系：
def minimize(self, loss, # 损失值， tensor # 全局训练步数，随着模型迭代优化自增， variable global_step=None, # 待训练模型参数的列表， list var_list=None, # 计算梯度和更新参数模型时的并行化程度，可选值GATE_OP,GATE_NONE,GATE_GRAPH # GATE_NONE 无同步，最大化并行执行效率，将梯度计算和模型参数更新完全并行化。 # GATE_OP，操作级同步，对于每个操作，分别确保所有梯度在使用前都计算完成。 # GATE_GRAPH，图级同步，最小化并行执行效率，确保所有模型参数的梯度计算完成。 gate_gradients=GATE_OP, # 聚集梯度值的方法， Enum aggregation_methed=None, # 是否将梯度计算放置到对应操作所在同一个设备，默认否，Boolean colocate_gradients_with_ops=False, # 优化器在数据流图中的名称，string nmae=None, # 损失值的梯度 grad_loss=None) 属性 功能介绍 _name 表示优化器的名称 _use_locking 表示是否在并发更新模型参数时加锁 minimize 最小化损失函数，该方法会依次调用compute_gradients和apply_gradients compute_gradients 计算模型所有参数的梯度值,返回&amp;lt;梯度，响应参数&amp;gt;的键值对列表 apply_gradients 将梯度值更新到对应的模型参数，优化器的apply_gradients成员方法内部会调用tf.</description></item><item><title>进阶操作</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0030_advance_operator/</link><pubDate>Wed, 08 Sep 2021 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0035_python/0020_internal_lib/0030_advance_operator/</guid><description>一、环境变量 1、临时环境变量 操作 说明 os.environ['WORKON_HOME']=&amp;quot;变量&amp;quot; 设置环境变量 os.environ['CUDA_VISIBLE_DEVICES']=&amp;quot;1&amp;quot; 设置显卡设备 os.environ.get('WORKON_HOME') 获取环境变量-方法1 os.getenv('path') 获取环境变量-方法2-推荐 del os.environ['WORKON_HOME'] 删除环境变量 os.environ['HOMEPATH'] 当前用户主目录 os.environ['TEMP'] 临时目录路径 os.environ['PATHEXT'] 可以执行文件 os.environ['SYSTEMROOT'] 系统主目录 os.environ['LOGONSERVER'] 机器名 os.environ['PROMPT'] 设置提示符 2、永久环境变量 操作 说明 功能 path = r&amp;quot;路径&amp;quot;</description></item><item><title>静态图</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0040_tf/w0010_compat/0010_tf_compat_summary/</link><pubDate>Wed, 08 Sep 2021 06:00:20 +0800</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0040_tf/w0010_compat/0010_tf_compat_summary/</guid><description>在TensorFlow 2中使用兼容性模块，必须使用tf.compat.v1替换tf，并且在导入TensorFlow软件包后添加一行tf.compat.v1.disable_eager_execution()函数来关闭eager执行模式。
import tensorflow as tf tf.compat.v1.disable_eager_execution() 简介 数据流是一种编程模型，被广泛地应用于并行计算中。TF使用数据流图来表示计算中各个运算之间的关系，在数据流图中，节点：表示计算单元(即：操作tf.Operation)；边：表示被计算单元消费/生产的数据(即：tf.Tensor)。 数据流图，可以被导出成一个可移植的、编程语言不相关的表示(ProtoBuf)，这种表示可以被其他语言使用，来创建一个图并在会话中使用它。
def graph_demo(): a = tf.constant([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=tf.float32) b = tf.constant([[10, 0, 0], [0, 0.5, 0], [0, 0, 2]]) c = tf.constant([[1, -1, 3]], dtype=tf.float32) y = tf.add(tf.matmul(a, b), c, name=&amp;#39;result&amp;#39;) writer = tf.summary.FileWriter(os.path.join(root_dir, &amp;#39;log/matmul&amp;#39;), tf.get_default_graph()) writer.close() return y # 在终端启动TensorBoard对图进行可视化 tensorboard --logdir log/matmul 上例中创建一个数据流图，然后用TensorBoard对这个图进行可视化。
tf.summary.FileWriter 创建了一个tf.summary.SummaryWriter来保存一个图像化表示，这个writer对象创建时，初始化参数包括：a.该图像化表示的存储路径；b.一个tf.Graph对象，可以使用tf.get_default_graph函数返回默认图 tf.get_default_graph 函数，返回默认图。 在执行时，调用TF API创建数据流图，这个阶段并没有进行计算。</description></item></channel></rss>