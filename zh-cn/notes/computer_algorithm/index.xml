<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computer Algorithm on biubiobiu's Blog</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/</link><description>Recent content in Computer Algorithm on biubiobiu's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Everything is mine</copyright><atom:link href="https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>二叉树-遍历</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/torch_summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/torch_summary/</guid><description>Depth First Search(DFS)遍历 # -*- coding: utf-8 -*- class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class Tree_Method: def DFS(self, root): &amp;#39;&amp;#39;&amp;#39; 深度优先遍历，即先访问根节点，然后遍历左子树接着遍历右子树。 主要利用栈的特点，先将右子树压栈，再将左子树压栈，这样左子树就位于栈顶， 可以结点的左子树先与右子树被遍历。 &amp;#39;&amp;#39;&amp;#39; if root == None: return None stack = [] &amp;#39;&amp;#39;&amp;#39;用列表模仿入栈&amp;#39;&amp;#39;&amp;#39; stack.append(root) while stack: &amp;#39;&amp;#39;&amp;#39;将栈顶元素出栈&amp;#39;&amp;#39;&amp;#39; current_node = stack.pop() print(current_node.value, end=&amp;#39; &amp;#39;) &amp;#39;&amp;#39;&amp;#39;判断该节点是否有右孩子，有就入栈&amp;#39;&amp;#39;&amp;#39; if current_node.right: stack.append(current_node.right) &amp;#39;&amp;#39;&amp;#39;判断该节点是否有左孩子，有就入栈&amp;#39;&amp;#39;&amp;#39; if current_node.left: def preOrder(self, root): &amp;#39;&amp;#39;&amp;#39;先序遍历&amp;#39;&amp;#39;&amp;#39; if root == None: return None print(root.value) self.</description></item><item><title>五大常用算法</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/dynamic_plan/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/dynamic_plan/</guid><description>分治法 分治法(divide and conquer)：
待解决复杂问题，能够简化为若干个小规模相同的问题，各个子问题独立存在，并且与原问题形式相同； 递归地解决各个子问题； 将各个子问题的解合并，得到原问题的解。 示例：
归并排序
动态规划 与分治法的不同：
动态规划与分治法相似，都是组合子问题的解来解决原问题，与分治法的不同在于：
分治法：将原问题划分为一个个不相交的子问题（比如：归并排序，将数组不断地划分为一个个的子数组进行排序，再将返回的两个有序数组进行合并排序） 动态规划：要解决的是子问题有重叠的问题，例如0-1背包问题。即：不同的子问题有公共的子子问题，这些重叠的子问题在动态规划中是不应该也不需要重新计算的，而是应该将其解以一定方式保存起来，提供给父问题使用。 设计步骤：
动态规划通常用来求解最优解问题，这类问题会有很多个解，每个解都对应一个值，而我们则希望在这些解中找到最优解（最大值或者最小值）。 通常四个步骤设计一个动态规划算法：
定义dp数组以及下标的含义； 推导出：递推公式 dp数组的初始化 遍历顺序 打印出dp数组 实现方法：
递归，属于自顶向下的计算方法：如果子问题有重复计算的情况下，需要一个备忘录来辅助实现，备忘录主要用来保存每一个子问题的解，当每个子问题只求一次，如果后续需要子问题的解，只需要查找备忘录中保存的结果，不必重复计算。 动态规划，属于自底向上的计算方法：此方法最常用，必须明确每个子问题规模的概念，使得任何子问题的求解都依赖于子子问题的解来进行求解。 示例：
0-1背包问题
贪心算法 贪心算法：在对问题求解时，总是做出在当前看来是做好的选择。即：当考虑做何种选择的时候，我们只考虑对当前问题最佳的选择而不考虑子问题的结果，这是贪心算法可行的第一个基本要素。不从整体最优上考虑，而是仅仅在某种意义上的局部最优解。贪心算法以迭代的方式作出相继的贪心选择，每做一次贪心选择就将问题简化为规模更小的子问题。
何时采用贪心算法：对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。
示例：
完全背包问题、均分纸牌、最大整数
实际上，贪心算法适用的情况很少。需要先证明：局部最优解会得出整体最优解，才可以使用。一旦证明能成立，它就是一种高效的算法。
例如【0-1背包问题】：即：对于每个物品，要么装要么不装(0或1)
有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。
物品： A B C D E F G
重量： 35 30 60 50 40 10 25
价值： 10 40 30 50 35 40 30</description></item><item><title>数据结果</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/data_struct/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/data_struct/</guid><description>数据结构 常见的数据结构可分为「线性数据结构」与「非线性数据结构」，具体为：「数组」、「链表」、「栈」、「队列」、「树」、「图」、「散列表」、「堆」。
散列表 散列表是一种非线性数据结构，通过利用 Hash 函数将指定的「键 key」映射至对应的「值 value」，以实现高效的元素查找。
比如：通过输入学号，在名字库里找到对应的名字。
# 输入：学号 # 小力: 10001 # 小特: 10002 # 小扣: 10003 # 名字库 names = [ &amp;#34;小力&amp;#34;, &amp;#34;小特&amp;#34;, &amp;#34;小扣&amp;#34; ] # Hash函数的目的：把学号，映射为序号index， # 这个序号index就是 名字库names的名字对应序号 堆 堆是一种基于「完全二叉树」的数据结构，可使用数组实现。以堆为原理的排序算法称为「堆排序」，基于堆实现的数据结构为「优先队列」。堆分为「大顶堆」和「小顶堆」，大（小）顶堆：任意节点的值不大于（小于）其父节点的值。
完全二叉树定义： 设二叉树深度为 k，若二叉树除第 k 层外的其它各层（第 1 至 k−1 层）的节点达到最大个数，且处于第 k 层的节点都连续集中在最左边，则称此二叉树为完全二叉树。
上图就是一个「小顶堆」，堆的操作：
搜索：$O(1)$，就是访问 堆顶的元素。 添加：就是要满足堆的定义：任意节点的值不大于（小于）其父节点的值。 删除：跟添加一样，就是要满足堆的定义：任意节点的值不大于（小于）其父节点的值。</description></item><item><title>滑动窗口</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/sliding_window/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/sliding_window/</guid><description>滑动窗口算法 参考
滑动窗口算法：是在给定特定窗口大小的数组或字符串上执行要求的操作，该技术可以将一部分问题中的嵌套循环转变为一个单循环，可以减少时间复杂度。即：在一个特定大小的字符串/数组上进行操作，而不是在整个字符串/数组上操作，这样就降低了问题的复杂度。
滑动：说明这个窗口是移动的；
窗口：窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；也可以是固定大小。
滑动窗口算法的思路：
我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。 我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。 此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。 重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。 对于固定窗口大小，框架总结如下：
# 固定窗口大小为k # 在s中 寻找窗口大小为k时的所包含最大元音字母个数 right = 0 while right&amp;lt;len(s): window.append(s[right]) right += 1 # 如果符合要求，说明窗口构造完成 if right&amp;gt;=k: # 这已经是一个窗口了，根据条件做一些事情 ... 可以计算窗口最大值 # 最后不要忘记把 【right-k】位置元素从窗口里移除 对于不固定窗口大小，框架总结如下：</description></item></channel></rss>