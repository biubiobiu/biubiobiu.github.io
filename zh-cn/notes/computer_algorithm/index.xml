<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computer Algorithm on biubiobiu's Blog</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/</link><description>Recent content in Computer Algorithm on biubiobiu's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Everything is mine</copyright><atom:link href="https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>LeedCode-经典</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0450_leedcode_classic.zh-ch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0450_leedcode_classic.zh-ch/</guid><description>标题 -- 数组 134. 加油站 关键点：每个加油站的 剩余=添加-消耗。 累积每个加油站的剩余量，剩余累积量达到最小值时（升高的拐点，注意累积量保持最小值不变的情况。），下一个加油站就是起点。 238. 除自身外数组的乘积 关键点：从左到右累积相乘，从右到左累积相乘。这样就不用除法，且避免了重复的计算。
189. 轮转数组 关键点：
方法一：环状替换：替换到下一个位置，直到回到原位置，完成一轮。如果有没有遍历的元素，偏移一个位置，继续环状替换操作。 方法二：多次翻转 &amp;ndash;达到&amp;ndash;&amp;gt; 旋转的效果 图 127. 单词接龙 关键点：单词与单词之间用“中间单词”连接。这样的设计是 降低了计算复杂度。
每个单词mask掉一个字母，单词与单词之间没有连接，是通过中间的单词相互连接 通过广度优先遍历，从起始单词开始，直到结束单词。由于路径中有一半的量是“中间单词”，所以总的步数N，应该缩小：N//2+1 class Solution(object): def __init__(self): self.nodeNum = 0 def ladderLength(self, beginWord, endWord, wordList): &amp;#34;&amp;#34;&amp;#34; :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int &amp;#34;&amp;#34;&amp;#34; def addWord(word): if word not in wordId: wordId[word] = self.</description></item><item><title>LeedCode刷库记录</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0500_leedcode_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0500_leedcode_list/</guid><description>参考
第一周：链表、栈、队列 链表的基础知识：单链表 反转链表（ LeetCode 206 ） 相交链表（ LeetCode 160 ） 合并两个有序链表 （ LeetCode 21 ） 分隔链表 （ LeetCode 86 ） 环形链表 II （ LeetCode 142 ） 反转链表 II （ LeetCode 92 ） 复制带随机指针的链表（ LeetCode 138 ） 栈的基础知识 有效的括号（ LeetCode 20 ） 基本计算器（ LeetCode 224 ） 最小栈（ LeetCode 155 ） 验证栈序列（ LeetCode 946 ） 每日温度（ LeetCode 739 ） 接雨水（ LeetCode 42 ） 队列的基础知识 用栈实现队列 （ LeetCode 232 ） 滑动窗口最大值（ LeetCode 239 ） 设计循环双端队列（ LeetCode 641 ） 移除链表元素（ LeetCode 203 ） K 个一组翻转链表（ LeetCode 25 ） 回文链表（ LeetCode 234 ） 奇偶链表（ LeetCode 328 ） 从尾到头打印链表（ 剑指Offer 06 ） 链表中倒数第 k 个节点（ 剑指Offer 22 ） 第二周，递归、排序、贪心 递归基础知识 冒泡排序基础知识 选择排序基础知识 插入排序基础知识 快速排序基础知识 计数排序基础知识 归并排序 桶排序（了解即 可） 堆排序 基数排序（了解即 可） 希尔排序（了解即 可） 合并两个有序数组( LeetCode 88 ) 颜色分类( LeetCode 75 ) 部分排序 （面试题 16） 计算右侧小于当前元素的个数 ( LeetCode 315 ) 合并 K 个升序链表（LeetCode 23 ） 有序数组的平方( LeetCode 977 ) 盛最多水的容器 ( LeetCode 11 ) 两数之和（LeetCode 1 ） 二叉堆基础知识 分发饼干（ LeetCode 455 ） 柠檬水找零（ LeetCode 860 ） 用最少数量的箭引爆气球（ LeetCode 452 ） 移掉 K 位数字（ LeetCode 402 ） 跳跃游戏（ LeetCode 55 ） 摆动序列（ LeetCode 376 ） 买卖股票的最佳时机 II（ LeetCode 122 ） 三数之和（LeetCode 15 ） 最接近三数之和（LeetCode 16 ） 加油站（ LeetCode 134 ） 合并区间（ LeetCode 56 ） 第三周，搜索算法、回溯算法、位运算、二分查找 二分查找基础知识 二分查找（ LeetCode 704 ） 搜索插入位置（ LeetCode 35 ） 在排序数组中查找元素的第一个和最后一个位置（ LeetCode 34 ） 搜索旋转排序数组（ LeetCode 33 ） 搜索二维矩阵（ LeetCode 74 ） 寻找两个正序数组的中位数（ LeetCode 4 ） 有效三角形的个数（ LeetCode 611 ） 剑指 Offer 53 – II.</description></item><item><title>二叉树-遍历</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0020_tree_search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0020_tree_search/</guid><description>Depth First Search(DFS)遍历 深度优先遍历：
使用递归，代码比较简单 如果不用递归，可以利用栈这种数据结构 # -*- coding: utf-8 -*- class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class Tree_Method: def DFS(self, root): &amp;#39;&amp;#39;&amp;#39; 深度优先遍历，即先访问根节点，然后遍历左子树接着遍历右子树。 主要利用栈的特点，先将右子树压栈，再将左子树压栈，这样左子树就位于栈顶， 可以结点的左子树先与右子树被遍历。 &amp;#39;&amp;#39;&amp;#39; if root == None: return None stack = [] &amp;#39;&amp;#39;&amp;#39;用列表模仿入栈&amp;#39;&amp;#39;&amp;#39; stack.append(root) while stack: &amp;#39;&amp;#39;&amp;#39;将栈顶元素出栈&amp;#39;&amp;#39;&amp;#39; current_node = stack.pop() print(current_node.value, end=&amp;#39; &amp;#39;) &amp;#39;&amp;#39;&amp;#39;判断该节点是否有右孩子，有就入栈&amp;#39;&amp;#39;&amp;#39; if current_node.right: stack.append(current_node.right) &amp;#39;&amp;#39;&amp;#39;判断该节点是否有左孩子，有就入栈&amp;#39;&amp;#39;&amp;#39; if current_node.left: stack.append(current_node.left) def preOrder(self, root): &amp;#39;&amp;#39;&amp;#39;先序遍历&amp;#39;&amp;#39;&amp;#39; if root == None: return None print(root.</description></item><item><title>五大常用算法</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0030_five_algorithms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0030_five_algorithms/</guid><description>分治法 分治法(divide and conquer)的工作原理：
找出简单的基线条件。 确定如何缩小问题的规模，使其符合基线条件。 分治法：并非可用于解决问题的算法，而是一种解决问题的思路。
待解决复杂问题，能够简化为若干个小规模相同的问题，各个子问题独立存在，并且与原问题形式相同； 递归地解决各个子问题； 将各个子问题的解合并，得到原问题的解。 实例1：
N和M的最大公约数（把一块农田均分成方块，求方块最大值）
实例2:
快速排序：
基线条件：空数组或者只有一个元素的数组，直接返回 选中一个基准值后，小于基准值的放在左边，大于基准值的放在右边。 def quick_sort(nums): if len(nums) &amp;lt; 2: return nums else: pivot = nums[0] lesser, greater = [], [] for item in nums[1:]: if item &amp;lt;= pivot: lesser.append(item) else: greater.append(item) return quick_sort(lesser) + [pivot] + quick_sort(greater) 实例3：
归并排序
实例4：
数组中最大值
普通的做法：设置个变量记录当前的最大值，变量数组中的每个值，最终找到数组的最大值。这中做法的时间复杂度 $O(n)$ 分治法：把数组分成两半：分别找打这两个子数组的最大值，再从这两个值中选出最大值。以此类推。这种做法的时间复杂度 $O(\log n)$ 贪心算法 近似算法：approximation algorithm.</description></item><item><title>图的搜索</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0050_graph_search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0050_graph_search/</guid><description>标题 -- 狄克斯特拉算法(Dijkstra) 参考算法解析 广度优先搜索：可以回答两类问题，即：适合非加权图
从节点A出发，有往节点B的路径吗？ 从节点A出发，前往节点B的那条路径最短。 狄克斯特拉算法(Dijkstra)：适合 没有负权边的加权图。
狄克斯特拉算法，假设：对于处理过的节点，没有前往该节点的更短路径。这种假设仅在没有负权边时才成立。 狄克斯特拉算法，是典型最短路径算法，用于计算一个结点到其他结点的最短路径。 它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 贝尔曼-福德算法：适合 包含负权边的加权图
狄克斯特拉算法(Dijkstra)包括4个步骤
找出”最便宜“的节点，即：可在最短时间内到达的节点 更新该节点的邻居的开销，检查是否有前往它们的更短路径，如果有，就更新其开销。 重复这个过程，直到对图中的每个节点都这样做了 计算最终路径 例如：乐谱 -换-&amp;gt; 钢琴
第一步：找出最便宜的节点。这里，换海报最便宜了，不需要支付额外的费用。
第二步：计算前往该节点的各个邻居的开销。
父节点：代表该节点的上一级最便宜节点。
第三步：目前条件(未遍历：黑胶唱片、吉他、架子鼓；已遍历：海报)，在目前未遍历节点中找下一个最便宜的节点是 ”黑胶唱片“；更新 ”黑胶唱片“ 的各个邻居的开销。
下一个最便宜的是 吉他，因此更新其邻居的开销： 下一个最便宜的是 架子鼓，因此更新其邻居的开销： 第四步：所有节点都已遍历完了，当前，我们直到最短路径的开销是35美元，但如何确定这条路径呢？为此，可以根据父节点寻找。
狄克斯特拉算法：python实例：乐谱 -换-&amp;gt; 钢琴 class Solution(object): def __init__(self): pass @staticmethod # 在未处理的节点中找出开销最小的节点 def find_lowest_cost_node(costs, processed): lowest_cost = float(&amp;#39;inf&amp;#39;) lowest_cost_node = None for node in costs: cost = costs[node] if cost &amp;lt; lowest_cost and node not in processed: lowest_cost = cost lowest_cost_node = node return lowest_cost_node def dikesi(self, graph): # 开销-散列表。未知节点的开销，先设置为无穷大 costs = { &amp;#39;A&amp;#39;: 0, &amp;#39;B&amp;#39;: 5, &amp;#39;C&amp;#39;: 0, &amp;#39;D&amp;#39;: float(&amp;#39;inf&amp;#39;), &amp;#39;E&amp;#39;: float(&amp;#39;inf&amp;#39;), &amp;#39;F&amp;#39;: float(&amp;#39;inf&amp;#39;) } # 父节点-散列表 parents = {&amp;#39;B&amp;#39;: &amp;#39;A&amp;#39;, &amp;#39;C&amp;#39;: &amp;#39;A&amp;#39;, &amp;#39;F&amp;#39;: None} # 已处理过的节点 processed = [] node = &amp;#39;A&amp;#39; while node is not None: cost = costs[node] neighbors = graph[node] # 遍历当前节点的所有邻居 for n in neighbors: new_cost = cost + neighbors[n] # 如果当前节点前往邻居更近，就更新该邻居的开销；同时更新该邻居的父节点 if costs[n] &amp;gt; new_cost: costs[n] = new_cost parents[n] = node processed.</description></item><item><title>常见算法思路</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0015_comm_ideas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0015_comm_ideas/</guid><description>标题 -- 递归 Leigh Caldwell在Stack Overflow上说的一句话: “如果使用循环，程序的性能可能更高;如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”
编写递归函数时，必须告诉它何时停止递归。正因为如此，每个递归函数都有两部分:
基线条件(base case)。指的是函数不再调用自己，从而避免形成无限循环。 递归条件(recursive case)。指的是函数调用自己。 二分查找 比如：从1~100的数字中，我认选一个，让你猜。我只会说：大了、小了、对了。需要猜多少次呢？
二分查找：一半一半的猜，每次都排除一半。所以需要的次数是：log2N。（向上取整）
class BinarySearch(object): # 迭代 def search_iterative(self, nums, item): low = 0 high = len(nums) - 1 while low&amp;lt;=high: mid = (low + high) // 2 guess = nums[mid] if guess == item: return mid elif guess &amp;gt; item: high = mid - 1 else: low = mid + 1 return None # 递归 def search_recursive(self, nums, low, high, item): if high &amp;gt;= low: mid = (high + low) // 2 guess = nums[mid] if guess == item: return mid elif guess &amp;gt; item: return self.</description></item><item><title>数据结果</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0010_data_struct/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0010_data_struct/</guid><description>数据结构 常见的数据结构可分为「线性数据结构」与「非线性数据结构」，具体为：「数组」、「链表」、「栈」、「队列」、「树」、「图」、「散列表」、「堆」。
数组与链表 数组： 在内存中是连续的一整块。
随机访问，数组在内存中是连续的一整块，所以支持随机访问。 增/删操作，费事。增加元素时，如果内存不够一整块，还得整体迁移 链表： 可以存储在内存的任何地方。
顺序访问，由于存在任何地方，每个元素都存储了下一个元素的地址，所以只能从头开始逐个查询。 增/删操作，不费事。只要修改一下 下一元素地址 就行。 栈 递归操作，就是使用的调用栈。即：把每个递归调用函数，都压入栈，完成一个弹出一个，直到空栈。
优先考虑用栈的 “信号”
有返回上一步的操作 成对匹配的问题，比如：（） 链表/list 的翻转问题，例如：K 个一组翻转链表 队列 队列(First In First Out)：先进先出的数据结构。
图的广度优先搜索，就是先把1级元素压入队列，然后在一个一个出队遍历时，把其邻居压入队列 树 字典树
字典树 ( Trie 树 ) 又称单词查找树， 是一种用于在 字符串集合 中 高效地 存储 和 查找 字符串 的 树形 数据结构。</description></item><item><title>滑动窗口</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0040_sliding_window/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0040_sliding_window/</guid><description>滑动窗口算法 参考
个人理解，滑动窗口主要解决的问题特点：
连续性，一定是连续序列或者字符串的最长/最短 的问题。 滑动窗口算法：是在给定特定窗口大小的数组或字符串上执行要求的操作，该技术可以将一部分问题中的嵌套循环转变为一个单循环，可以减少时间复杂度。即：在一个特定大小的字符串/数组上进行操作，而不是在整个字符串/数组上操作，这样就降低了问题的复杂度。
滑动：说明这个窗口是移动的；
窗口：窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；也可以是固定大小。
滑动窗口算法的思路：
我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。 我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。 此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。 重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。 对于固定窗口大小，框架总结如下：
# 固定窗口大小为k # 在s中 寻找窗口大小为k时的所包含最大元音字母个数 right = 0 while right&amp;lt;len(s): window.append(s[right]) right += 1 # 如果符合要求，说明窗口构造完成 if right&amp;gt;=k: # 这已经是一个窗口了，根据条件做一些事情 .</description></item></channel></rss>