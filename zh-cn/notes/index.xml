<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>笔记 on biubiobiu's Blog</title><link>https://biubiobiu.github.io/zh-cn/notes/</link><description>Recent content in 笔记 on biubiobiu's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Everything is mine</copyright><lastBuildDate>Tue, 08 Jun 2010 08:06:25 +0600</lastBuildDate><atom:link href="https://biubiobiu.github.io/zh-cn/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Search Results</title><link>https://biubiobiu.github.io/zh-cn/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>অনুসন্ধানের ফলাফল</title><link>https://biubiobiu.github.io/zh-cn/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://biubiobiu.github.io/zh-cn/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://biubiobiu.github.io/zh-cn/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://biubiobiu.github.io/zh-cn/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://biubiobiu.github.io/zh-cn/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://biubiobiu.github.io/zh-cn/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://biubiobiu.github.io/zh-cn/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://biubiobiu.github.io/zh-cn/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://biubiobiu.github.io/zh-cn/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://biubiobiu.github.io/zh-cn/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Resultados de Búsqueda</title><link>https://biubiobiu.github.io/zh-cn/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/search/</guid><description>Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.
No se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html
Establecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.
Esta implementación utiliza Fusejs, jquery y mark.js
Configuración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.</description></item><item><title>NdArray使用</title><link>https://biubiobiu.github.io/zh-cn/notes/mxnet/ndarray/0010_ndarray_summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/mxnet/ndarray/0010_ndarray_summary/</guid><description>查阅文档 怎么查阅相关文档？ 官网
1. 查阅模块里的所有函数和类 from mxnet import nd print(dir(nd.random)) __开头和结尾的函数 (python的特别对象) 可以忽略 _开头的函数 (一般为内部函数) 可以忽略 其余成员，可以根据名字 大致猜出是什么意思。 2. 查阅特定函数和类的使用 想了解某个函数或者类的具体用法，可以使用help函数。以NDArray中的ones_like函数为例。
help(nd.ones_like) 注意：
jupyter记事本里，使用?来将文档显示在另外一个窗口中。例如：nd.ones_like? 与 help(nd.ones_like)效果一样。nd.ones_like??会额外显示该函数实现的代码。 内存开销 原始操作 首先来个例子：Y = Y + X &amp;ndash;&amp;gt; 每个操作会新开内存来存储运算结果。 上例中，X，Y 变量首先存储在内存中，相加的计算结果会另外开辟内存来存储；然后变量Y在指向新的内存。 内存使用情况：
内存id_x &amp;lt;&amp;ndash; X 内存id_y &amp;lt;&amp;ndash; Y 内存id_x+y &amp;lt;&amp;ndash; Y
Y[:] = X + Y 或者 Y += X 通过[:]把X+Y的结果写进Y对应的内存中。上述操作中，需要另外开辟内存来存储计算结果。 内存使用情况： 内存id_x &amp;lt;&amp;ndash; X 内存id_y &amp;lt;&amp;ndash; Y 内存id_x+y &amp;ndash;&amp;gt; 把内存id_x+y中数值复制到内存id_y中</description></item><item><title>滑动窗口</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0040_sliding_window/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0040_sliding_window/</guid><description>滑动窗口算法 参考
滑动窗口算法：是在给定特定窗口大小的数组或字符串上执行要求的操作，该技术可以将一部分问题中的嵌套循环转变为一个单循环，可以减少时间复杂度。即：在一个特定大小的字符串/数组上进行操作，而不是在整个字符串/数组上操作，这样就降低了问题的复杂度。
滑动：说明这个窗口是移动的；
窗口：窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；也可以是固定大小。
滑动窗口算法的思路：
我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。 我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。 此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。 重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。 对于固定窗口大小，框架总结如下：
# 固定窗口大小为k # 在s中 寻找窗口大小为k时的所包含最大元音字母个数 right = 0 while right&amp;lt;len(s): window.append(s[right]) right += 1 # 如果符合要求，说明窗口构造完成 if right&amp;gt;=k: # 这已经是一个窗口了，根据条件做一些事情 ... 可以计算窗口最大值 # 最后不要忘记把 【right-k】位置元素从窗口里移除 对于不固定窗口大小，框架总结如下：</description></item><item><title>数据结果</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0010_data_struct/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0010_data_struct/</guid><description>数据结构 常见的数据结构可分为「线性数据结构」与「非线性数据结构」，具体为：「数组」、「链表」、「栈」、「队列」、「树」、「图」、「散列表」、「堆」。
数组与链表 数组： 在内存中是连续的一整块。
随机访问，数组在内存中是连续的一整块，所以支持随机访问。 增/删操作，费事。增加元素时，如果内存不够一整块，还得整体迁移 链表： 可以存储在内存的任何地方。
顺序访问，由于存在任何地方，每个元素都存储了下一个元素的地址，所以只能从头开始逐个查询。 增/删操作，不费事。只要修改一下 下一元素地址 就行。 栈 递归操作，就是使用的调用栈。即：把每个递归调用函数，都压入栈，完成一个弹出一个，直到空栈。 队列 队列(First In First Out)：先进先出的数据结构。
图的广度优先搜索，就是先把1级元素压入队列，然后在一个一个出队遍历时，把其邻居压入队列 散列表 散列函数：将任何输入映射到数字。
在pyhton中 散列表的实现为字典 dict()
散列表是一种非线性数据结构，通过利用 Hash 函数将指定的「键 key」映射至对应的「值 value」，以实现高效的元素查找。
比如：通过输入学号，在名字库里找到对应的名字。
# 输入：学号 # 小力: 10001 # 小特: 10002 # 小扣: 10003 # 名字库 names = [ &amp;#34;小力&amp;#34;, &amp;#34;小特&amp;#34;, &amp;#34;小扣&amp;#34; ] # Hash函数的目的：把学号，映射为序号index， # 这个序号index就是 名字库names的名字对应序号 堆 堆是一种基于「完全二叉树」的数据结构，可使用数组实现。以堆为原理的排序算法称为「堆排序」，基于堆实现的数据结构为「优先队列」。堆分为「大顶堆」和「小顶堆」，大（小）顶堆：任意节点的值不大于（小于）其父节点的值。</description></item><item><title>常见算法思路</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0015_comm_ideas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0015_comm_ideas/</guid><description>递归 Leigh Caldwell在Stack Overflow上说的一句话: “如果使用循环，程序的性能可能更高;如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”
编写递归函数时，必须告诉它何时停止递归。正因为如此，每个递归函数都有两部分:
基线条件(base case)。指的是函数不再调用自己，从而避免形成无限循环。 递归条件(recursive case)。指的是函数调用自己。 最大公约数 原始：求两个数(N, M)的最大公约数。 变形1：假设你是农场主，有一小块土地。你要将这块地均匀地分成方块，且分出的方块要尽可能大。 伪代码-思路： 假设：N表示较小的数，M表示较大的数。 重复一下操作，直到 N=0 新N = M % N 新M = 原N 图的搜索 广度优先搜索：可以回答两类问题，即：适合非加权图
从节点A出发，有往节点B的路径吗？ 从节点A出发，前往节点B的那条路径最短。 狄克斯特拉算法：适合 没有负权边的加权图。
狄克斯特拉算法，假设：对于处理过的节点，没有前往该节点的更短路径。这种假设仅在没有负权边时才成立。 贝尔曼-福德算法：适合 包含负权边的加权图
狄克斯特拉算法包括4个步骤
找出”最便宜“的节点，即：可在最短时间内到达的节点 更新该节点的邻居的开销，检查是否有前往它们的更短路径，如果有，就更新其开销。 重复这个过程，直到对图中的每个节点都这样做了 计算最终路径 例如：乐谱 -换-&amp;gt; 钢琴</description></item><item><title>五大常用算法</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0030_five_algorithms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0030_five_algorithms/</guid><description>分治法 分治法(divide and conquer)的工作原理：
找出简单的基线条件。 确定如何缩小问题的规模，使其符合基线条件。 分治法：并非可用于解决问题的算法，而是一种解决问题的思路。
待解决复杂问题，能够简化为若干个小规模相同的问题，各个子问题独立存在，并且与原问题形式相同； 递归地解决各个子问题； 将各个子问题的解合并，得到原问题的解。 实例1：
N和M的最大公约数（把一块农田均分成方块，求方块最大值）
实例2:
快速排序：
基线条件：空数组或者只有一个元素的数组，直接返回 选中一个基准值后，小于基准值的放在左边，大于基准值的放在右边。 实例3：
归并排序
贪心算法 近似算法：approximation algorithm. 在获得精确解需要的时间太长时，可使用近似算法。判断近似算法优劣的标准如下：
速度有多快 得到的近似解与最优解的接近程度 NP完全问题：就是以难解著称的问题。很多非常聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。
集合覆盖问题：有n个广播站，每个广播站可能覆盖几个省(覆盖有重复)，想要覆盖全国，最少需要选那几个广播站。每个广播站覆盖的范围：是一个集合。想要全集：选最少个集合，并集是全集。 旅行商问题：旅行商打算旅行n个城市，找出前往这n个城市的最短路径。如果要找最优解：有n!种可能。 如何识别NP完全问题：如果能够判断是NP完全问题，这样就好了，就不用去寻找完美的解决方案，而是使用近似算法即可。
元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢 涉及所有组合的问题，通常是NP完全问题 不能将问题分成小问题，必须考虑各种可能的情况，这可能是NP完全问题 如果问题涉及序列(比如：旅行商问题中的城市序列) 且难以解决，可能就是NP完全问题 如果问题涉及集合(比如：广播台集合) 且难以解决，可能就是NP完全问题 如果问题可转换为集合问题、旅行商问题，它肯定就是NP完全问题。 贪心算法：
贪心算法，是寻找局部最优解，企图以这种方式获得全局最优解 面对NP完全问题，还没有找到快速解决方案。最佳的做法是使用近似算法 贪心算法，是一种易于实现、运行速度快 的近似算法。 贪心算法解决的问题：</description></item><item><title>二叉树-遍历</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0020_tree_search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0020_tree_search/</guid><description>Depth First Search(DFS)遍历 # -*- coding: utf-8 -*- class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class Tree_Method: def DFS(self, root): &amp;#39;&amp;#39;&amp;#39; 深度优先遍历，即先访问根节点，然后遍历左子树接着遍历右子树。 主要利用栈的特点，先将右子树压栈，再将左子树压栈，这样左子树就位于栈顶， 可以结点的左子树先与右子树被遍历。 &amp;#39;&amp;#39;&amp;#39; if root == None: return None stack = [] &amp;#39;&amp;#39;&amp;#39;用列表模仿入栈&amp;#39;&amp;#39;&amp;#39; stack.append(root) while stack: &amp;#39;&amp;#39;&amp;#39;将栈顶元素出栈&amp;#39;&amp;#39;&amp;#39; current_node = stack.pop() print(current_node.value, end=&amp;#39; &amp;#39;) &amp;#39;&amp;#39;&amp;#39;判断该节点是否有右孩子，有就入栈&amp;#39;&amp;#39;&amp;#39; if current_node.right: stack.append(current_node.right) &amp;#39;&amp;#39;&amp;#39;判断该节点是否有左孩子，有就入栈&amp;#39;&amp;#39;&amp;#39; if current_node.left: def preOrder(self, root): &amp;#39;&amp;#39;&amp;#39;先序遍历&amp;#39;&amp;#39;&amp;#39; if root == None: return None print(root.value) self.</description></item><item><title>LeedCode刷库记录</title><link>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0500_leedcode_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/computer_algorithm/0500_leedcode_list/</guid><description>参考
第一周：链表、栈、队列 链表的基础知识：单链表 反转链表（ LeetCode 206 ） 相交链表（ LeetCode 160 ） 合并两个有序链表 （ LeetCode 21 ） 分隔链表 （ LeetCode 86 ） 环形链表 II （ LeetCode 142 ） 反转链表 II （ LeetCode 92 ） 复制带随机指针的链表（ LeetCode 138 ） 栈的基础知识 有效的括号（ LeetCode 20 ） 基本计算器（ LeetCode 224 ） 最小栈（ LeetCode 155 ） 验证栈序列（ LeetCode 946 ） 每日温度（ LeetCode 739 ） 接雨水（ LeetCode 42 ） 队列的基础知识 用栈实现队列 （ LeetCode 232 ） 滑动窗口最大值（ LeetCode 239 ） 设计循环双端队列（ LeetCode 641 ） 移除链表元素（ LeetCode 203 ） K 个一组翻转链表（ LeetCode 25 ） 回文链表（ LeetCode 234 ） 奇偶链表（ LeetCode 328 ） 从尾到头打印链表（ 剑指Offer 06 ） 链表中倒数第 k 个节点（ 剑指Offer 22 ） 第二周，递归、排序、贪心 递归基础知识 冒泡排序基础知识 选择排序基础知识 插入排序基础知识 快速排序基础知识 计数排序基础知识 归并排序 桶排序（了解即 可） 堆排序 基数排序（了解即 可） 希尔排序（了解即 可） 合并两个有序数组( LeetCode 88 ) 颜色分类( LeetCode 75 ) 部分排序 （面试题 16） 计算右侧小于当前元素的个数 ( LeetCode 315 ) 合并 K 个升序链表（LeetCode 23 ） 有序数组的平方( LeetCode 977 ) 盛最多水的容器 ( LeetCode 11 ) 两数之和（LeetCode 1 ） 二叉堆基础知识 分发饼干（ LeetCode 455 ） 柠檬水找零（ LeetCode 860 ） 用最少数量的箭引爆气球（ LeetCode 452 ） 移掉 K 位数字（ LeetCode 402 ） 跳跃游戏（ LeetCode 55 ） 摆动序列（ LeetCode 376 ） 买卖股票的最佳时机 II（ LeetCode 122 ） 三数之和（LeetCode 15 ） 最接近三数之和（LeetCode 16 ） 加油站（ LeetCode 134 ） 合并区间（ LeetCode 56 ） 第三周，搜索算法、回溯算法、位运算、二分查找 二分查找基础知识 二分查找（ LeetCode 704 ） 搜索插入位置（ LeetCode 35 ） 在排序数组中查找元素的第一个和最后一个位置（ LeetCode 34 ） 搜索旋转排序数组（ LeetCode 33 ） 搜索二维矩阵（ LeetCode 74 ） 寻找两个正序数组的中位数（ LeetCode 4 ） 有效三角形的个数（ LeetCode 611 ） 剑指 Offer 53 – II.</description></item><item><title>Gluon模块简介</title><link>https://biubiobiu.github.io/zh-cn/notes/mxnet/gluon/0020_module_gather/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/mxnet/gluon/0020_module_gather/</guid><description>gluon模块-结构 路径.mxnet/gluon/下的树状结构:
│　block.py 类：Block, HybridBlock
│　loss.py 各种loss函数
│　parameter.py 类：Parameter, Constant, ParameterDict
│　trainer.py 类：Trainer
│　utils.py 优化操作
│　init.py
│
├─contrib
│　│
│　├─cnn
│　│　└─ conv_layers.py
│　├─data
│　│　└─ sampler.py
│　│
│　├─estimator
│　│　│　estimator.py
│　│　└─ event_handler.py
│　│
│　├─nn
│　│　└─ basic_layers.py
│　│
│　└─rnn
│　│　conv_rnn_cell.py
│　└─ rnn_cell.py
│
├─data 主要是数据处理操作</description></item><item><title>Gluon实例</title><link>https://biubiobiu.github.io/zh-cn/notes/mxnet/gluon/0010_gluon_summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/mxnet/gluon/0010_gluon_summary/</guid><description>实例-单层感知机 模型：o = w1*x1 + w2*x2 + b 输出o作为线性回归的输出，输入层是2维特征；输入层不涉及计算，该神经网络只有输出层1层。
神经元：输出层中负责计算o的单元。
该神经元，依赖于输入层的全部特征，也就是说输出层中的神经元和输入层中各个输入完全连接，所以，这里的输出层又叫作全连接层(fully connected layer)或者稠密层(dense layer)
生成数据集 目标： o = 2x1 - 3.4x2 + 4.2 其中： 样本集：features: [w1, w2]， labels: [真实值+噪声]
from IPython import display from matplotlib import pyplot as plt from mxnet import autograd, nd import random num_inputs = 2 num_examples = 1000 true_w = [2, -3.4] true_b = 4.2 features = nd.random.normal(scale=1, shape=(num_examples, num_inputs)) labels = true_w[0] * features[:, 0] + true_w[1] * features[:, 1] + true_b labels += nd.</description></item><item><title>Gluon-nn模块</title><link>https://biubiobiu.github.io/zh-cn/notes/mxnet/gluon/0030_module_gluon_nn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/mxnet/gluon/0030_module_gluon_nn/</guid><description>模型基类-Block from mxnet.gluon import Block, nn from mxnet import ndarray as F class Model(Block): def __init__(self, **kwargs): super(Model, self).__init__(**kwargs) # use name_scope to give child Blocks appropriate names. with self.name_scope(): self.dense0 = nn.Dense(20) self.dense1 = nn.Dense(20) def forward(self, x): x = F.relu(self.dense0(x)) return F.relu(self.dense1(x)) model = Model() model.initialize(ctx=mx.cpu(0)) model(F.zeros((10, 10), ctx=mx.cpu(0))) class Block(builtins.object)
网络的最基础的类，搭建网络时必须继承此Block类 —————————————————
Block的两个参数：
prefix : str; 前缀的作用就像一个命名空间。在父模块的作用域下创建的子模块都有父模块的前缀(prefix). params : ParameterDict or None; 共享参数。
例如：dense1共享dense0的参数。
dense0 = nn.</description></item><item><title>NdArray技巧搜集</title><link>https://biubiobiu.github.io/zh-cn/notes/mxnet/ndarray/0020_technic_gather/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/notes/mxnet/ndarray/0020_technic_gather/</guid><description>sum/mean等操作 - 保留原维度数 keepdims: 保留原维度数。例如：
from mxnet import nd def softmax(X): X_exp = X.exp() # shape = (n, m) # shape = (n, 1) 而并不是 (n,) partition = X_exp.sum(axis=1, keepdims=True) return X_exp / partition # 这里应用了广播机制 X = nd.random.normal(shape=(2, 5)) X_prob = softmax(X) B的值作为A的索引 - 取值 from mxnet import nd y_hat = nd.array([[0.1, 0.3, 0.6], [0.3, 0.2, 0.5]]) y = nd.array([0, 2], dtype=&amp;#39;int32&amp;#39;) nd.pick(y_hat, y) # 结果: [0.</description></item><item><title>Search Results</title><link>https://biubiobiu.github.io/zh-cn/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biubiobiu.github.io/zh-cn/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item></channel></rss>