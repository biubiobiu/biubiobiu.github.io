<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tensor on biubiobiu's Blog</title><link>https://biubiobiu.github.io/zh-cn/tags/tensor/</link><description>Recent content in Tensor on biubiobiu's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Everything is mine</copyright><lastBuildDate>Fri, 08 Apr 2022 06:00:20 +0600</lastBuildDate><atom:link href="https://biubiobiu.github.io/zh-cn/tags/tensor/index.xml" rel="self" type="application/rss+xml"/><item><title>Tensor和变量</title><link>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0050_pytorch/0040_tensor/</link><pubDate>Fri, 08 Apr 2022 06:00:20 +0600</pubDate><guid>https://biubiobiu.github.io/zh-cn/posts/00035_programming_language/0050_pytorch/0040_tensor/</guid><description>Tensor
每个张量Tensor都有一个相应的torch.Storage，用来保存数据。
torch.Storage: 是一个单一数据类型的连续一维数组。每个Tensor都有一个对应的相同数据类型的存储：class torch.FloatStorage 类tensor：提供了一个存储 多维的、横向视图，并定义了数值运算。 torch.Tensor.abs()：会在原地计算，并返回改变后的tensor
torch.Tensor.abd()：在一个新的tensor中计算结果 变量
Variable 在torch.autograd.Variable中，Variable的结构图：data：Variable的tensor数值 grad_fn：表示得到这个Variable的操作，
grad：表示Variable的反向传播梯度 示例1：x = Variable(torch.Tensor([1]), requires_grad=Ture) 其中：requires_grad=True ：这个参数表示是否对这个变量求梯度。
x.backward()：自动求导。自动求导不需要再去明确地写明那个函数对那个函数求导，直接通过这行代码就可以对所有的需要梯度的变量进行求导。
x.grad：存放的就是x的梯度值 示例2：y.backward(torch.FloatTensor([1,0.1,0.01]))，表示得到的梯度分别乘以1,0.1,0.01 Variable和Tensor本质上没有区别，不过Variable会被放入一个计算图中，然后进行前向传播、反向传播、自动求导。 tensor与Variable之间的转换： tensor —to—&amp;gt; Variable：b=Variable(a) 一、Tensor信息 torch.is_tensor(obj) 判断是否为tensor torch.is_storage(obj) 判断obj是一个pytorch storage对象 torch.set_default_tensor_type() torch.numel(Tensor) 返回张量中元素的个数 二、创建Tensor torch.Tensor([[1,2],[3,4]])。创建&amp;mdash;返回指定数值的张量 torch.randn(*sizes, out=None)。创建&amp;mdash;返回标准正态分布的随机数张量。标准正态分布，形状由sizes定义 torch.randperm(n, out=None)。创建&amp;mdash;返回0~n-1之间的随机整数1维张量。返回一个从0~n-1的随机整数排列 torch.rand(*sizes, out=None)。创建&amp;mdash;返回[0, 1)的均匀分布张量 torch.arange(start, end, step=1, out=None)。创建&amp;mdash;返回一个1维张量。[start, end) 以step为步长的一组序列值 torch.range(start, end, step=1, out=None)。创建&amp;mdash;返回一个1维张量。[start, end) 以step为步长的1维张量 torch.zeros(*sizes, out=None)。创建&amp;mdash;返回一个全为0的张量。生成一个tensor, 数值为0，形状由sizes定义 torch.</description></item></channel></rss>